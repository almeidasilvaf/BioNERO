#' Pick power to fit network to a scale-free topology
#'
#' @param exp Normalized expression table, where rownames are gene IDs and colnames are sample names
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'. Default is signed.
#' @param rsquared R squared cutoff. Default is 0.8.
#' @param cor_method Correlation method. One of "pearson", "biweight" or "spearman". Default is "spearman".
#'
#' @return A list containing: \itemize{
#'   \item{power}{Optimal power based on scale-free topology fit}
#'   \item{plot}{A ggplot object displaying main statistics of the SFT fit test}
#' } Power to fit network to a scale-free topology and SFT fit plots in PDF in the user's working directory
#'
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{pickSoftThreshold}}
#' @rdname SFT_fit
#' @export
#' @importFrom WGCNA pickSoftThreshold
#' @importFrom graphics abline legend par points text
#' @importFrom ggpubr ggarrange
#' @examples
#' data(se.seed)
#' filt.se <- filter_by_variance(se.seed, n=500)
#' sft <- SFT_fit(filt.se, cor_method="pearson")
SFT_fit <- function(exp, net_type="signed", rsquared=0.8, cor_method="spearman") {
    exp <- handleSE(exp)
    texp <- t(exp)

    if(cor_method == "pearson") {
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20, RsquaredCut = rsquared)
    } else if(cor_method == "biweight") {
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20,
                                        RsquaredCut = rsquared, corFnc = bicor, corOptions = list(use = 'p', maxPOutliers = 0.05))
    } else if (cor_method == "spearman"){
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20,
                                        RsquaredCut = rsquared, corOptions = list(use = 'p', method = "spearman"))
    } else {
        stop("Please, specify a correlation method (one of 'spearman', 'pearson' or 'biweight').")
    }
    wgcna_power <- sft$powerEstimate
    if(is.na(wgcna_power)){
        message("No power reached R-squared cut-off, now choosing max R-squared based power")
        wgcna_power <- sft$fitIndices$Power[which(sft$fitIndices$SFT.R.sq == max(sft$fitIndices$SFT.R.sq))]
    }

    # Create data frame with indices to plot
    sft_df <- data.frame(power = sft$fitIndices[,1],
                         fit = -sign(sft$fitIndices[,3]) * sft$fitIndices[,2],
                         meank = sft$fitIndices[,5])
    # Plot 1
    p1 <- ggpubr::ggscatter(sft_df, x="power", y="fit",
                            xlab="Soft threshold (power)",
                            ylab=expression(paste("Scale-free topology fit - ", R^{2})),
                            title = "Scale independence",
                            ylim=c(0, 1), label="power", size=1,
                            font.label=10,
                            color="gray10",
                            font.tickslab=10, ytickslab.rt=90) +
        geom_hline(yintercept = rsquared, color="brown3") +
        theme(plot.title = element_text(hjust = 0.5))

    # Plot 2
    p2 <- ggscatter(sft_df, x="power", y="meank",
                    xlab="Soft threshold (power)", ylab="Mean connectivity (k)",
                    title="Mean connectivity",
                    label="power", size=1, font.label=10, color="gray10",
                    font.tickslab=10, ytickslab.rt=90) +
        theme(plot.title = element_text(hjust=0.5))

    # Combined plot
    sft_plot <- ggpubr::ggarrange(p1, p2)
    result <- list(power=as.numeric(wgcna_power), plot=sft_plot)
    return(result)
}


#' Reconstruct gene coexpression network from gene expression data frame
#'
#' @param norm.exp Normalized gene expression data frame, where row names are gene IDs and column names are sample names.
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'.
#' @param module_merging_threshold Maximum dissimilarity (1-cor) between module for module merging. As it is based on dissimilarity, a threshold of 0.2 means that module eigengenes must be at least 0.8 similar to be merged. Default is 0.2.
#' @param SFTpower SFT power generated by the function \code{SFT_fit}.
#' @param cor_method Correlation method. One of "pearson", "biweight" or "spearman". Default is "spearman", considering that the expression data does not follow a normal distribution.
#'
#' @return List containing: \itemize{
#'   \item Adjacency matrix
#'   \item Data frame of module eigengenes
#'   \item Data frame of genes and their corresponding modules
#'   \item Data frame of intramodular connectivity
#'   \item Vector of module assignment
#'   \item Correlation matrix
#'   \item Parameters used for network reconstruction
#' }
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{adjacency.fromSimilarity}},\code{\link[WGCNA]{TOMsimilarity}},\code{\link[WGCNA]{standardColors}},\code{\link[WGCNA]{labels2colors}},\code{\link[WGCNA]{moduleEigengenes}},\code{\link[WGCNA]{plotEigengeneNetworks}},\code{\link[WGCNA]{mergeCloseModules}},\code{\link[WGCNA]{plotDendroAndColors}},\code{\link[WGCNA]{intramodularConnectivity}}
#'  \code{\link[dynamicTreeCut]{cutreeDynamicTree}}
#' @rdname exp2net
#' @export
#' @importFrom WGCNA adjacency.fromSimilarity TOMsimilarity standardColors labels2colors moduleEigengenes plotEigengeneNetworks mergeCloseModules plotDendroAndColors intramodularConnectivity
#' @importFrom dynamicTreeCut cutreeDynamicTree
#' @importFrom stats as.dist median cor fisher.test hclust na.omit prcomp qnorm qqplot quantile sd var
#' @importFrom grDevices colorRampPalette dev.off pdf
exp2net <- function(norm.exp, net_type="signed hybrid", module_merging_threshold = 0.2,
                    SFTpower, cor_method = "spearman") {

    params <- list(net_type=net_type,
                   module_merging_threshold=module_merging_threshold,
                   SFTpower=SFTpower,
                   cor_method=cor_method)

    if(is.null(SFTpower)) {
        stop("Please, specify the SFT power")
    }

    message("Calculating adjacency matrix...")
    if(cor_method == "pearson") {
        cor_matrix <- cor(t(norm.exp), method = "pearson")
        adj_matrix <- WGCNA::adjacency.fromSimilarity(cor_matrix, power = SFTpower, type=net_type)
    } else if(cor_method == "spearman") {
        cor_matrix <- cor(t(norm.exp), use="p", method = "spearman")
        adj_matrix <- WGCNA::adjacency.fromSimilarity(cor_matrix, power=SFTpower, type=net_type)
    } else if (cor_method == "biweight") {
        cor_matrix <- WGCNA::bicor(t(norm.exp), maxPOutliers = 0.1)
        adj_matrix <- WGCNA::adjacency.fromSimilarity(cor_matrix, power=SFTpower, type=net_type)
    } else {
        stop("Please, specify a correlation method. One of 'spearman', 'pearson' or 'biweight'.")
    }
    message("Removing diagonals...")
    diag(adj_matrix) <- 0

    #Convert to matrix
    gene_ids <- rownames(adj_matrix)
    adj_matrix <- matrix(adj_matrix, nrow=nrow(adj_matrix))
    rownames(adj_matrix) <- gene_ids
    colnames(adj_matrix) <- gene_ids

    #Calculate TOM from adjacency matrix
    message("Calculating topological overlap matrix (TOM)...")
    if(net_type == "signed hybrid") {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "signed")
    } else if(net_type == "signed") {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "signed Nowick")
    } else {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "unsigned")
    }


    #Hierarchically cluster genes
    dissTOM <- 1-TOM #hclust takes a distance structure
    geneTree <- hclust(as.dist(dissTOM), method="average")

    #Detecting coexpression modules
    message("Detecting coexpression modules...")
    old.module_labels <- dynamicTreeCut::cutreeDynamicTree(dendro=geneTree, minModuleSize=30,
                                                           deepSplit=TRUE)

    nmod <- length(unique(old.module_labels))
    palette <- rev(WGCNA::standardColors(nmod))
    old.module_colors <- WGCNA::labels2colors(old.module_labels, colorSeq = palette)

    #Calculate eigengenes and merge the ones who are highly correlated
    message("Calculating module eigengenes (MEs)...")
    old.MElist <- WGCNA::moduleEigengenes(t(norm.exp), colors = old.module_colors, softPower = SFTpower)
    old.MEs <- old.MElist$eigengenes

    #Calculate dissimilarity of module eigengenes
    MEDiss1 <- 1-cor(old.MEs)

    #Hierarchically cluster module eigengenes to see how they're related
    old.METree <- hclust(as.dist(MEDiss1), method="average")

    #Then, choose a height cut
    MEDissThreshold <- module_merging_threshold

    #Merge the modules.
    message("Merging similar modules...")
    if(cor_method == "pearson") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, colorSeq=palette)
    } else if(cor_method == "spearman") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, corOptions = list(use = "p", method = "spearman"),
                                           colorSeq=palette)
    } else if(cor_method == "biweight") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, corFnc = bicor, colorSeq=palette)
    } else {
        stop("Please, specify a correlation method. One of 'spearman', 'pearson' or 'biweight'.")
    }
    new.module_colors <- merge1$colors
    new.MEs <- merge1$newMEs #calculate the eigengenes of new modules

    #Plot dendrogram of merged modules eigengenes
    new.METree <- hclust(as.dist(1-cor(new.MEs)), method="average")

    pdf(file = "Eigengene_network.pdf", width=9, height=9)
    par(cex=0.8)
    eigennetwork_aftermerging <- WGCNA::plotEigengeneNetworks(new.MEs, "",
                                                              marDendro=c(3,3,2,4),
                                                              marHeatmap=c(3,4,2,2))
    dev.off()

    #See dendrogram with colors to analyze how old modules and merged modules differ
    pdf(file="Dendrogram_and_module_colors_before_and_after_merging.pdf", width = 9, height=9)
    dendroandcolors_comparison <- WGCNA::plotDendroAndColors(geneTree, cbind(old.module_colors, new.module_colors), c("Unmerged", "Merged"),
                                                             dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
    dev.off()

    #Get data frame with genes and modules they belong to
    genes_and_modules <- as.data.frame(cbind(gene_ids, new.module_colors), stringsAsFactors = FALSE)
    colnames(genes_and_modules) <- c("Genes", "Modules")

    message("Calculating intramodular connectivity...")
    intramodular_k_allmodules <- WGCNA::intramodularConnectivity(adj_matrix, new.module_colors)

    result.list <- list(adjacency_matrix = adj_matrix,
                        MEs = new.MEs,
                        genes_and_modules = genes_and_modules,
                        kIN = intramodular_k_allmodules,
                        moduleColors = new.module_colors,
                        correlation_matrix = cor_matrix,
                        params=params)

    return(result.list)
}

#' Perform module stability analysis
#'
#' @param norm.exp Normalized gene expression data frame, where row names are gene IDs and column names are sample names.
#' @param net List object returned by \code{exp2net}.
#' @param nRuns Number of times to resample. Default is 30.
#'
#' @return A .pdf file in the current working directory representing the module stability across the resamplings.
#' @seealso
#'  \code{\link[WGCNA]{sampledBlockwiseModules}},\code{\link[WGCNA]{matchLabels}},\code{\link[WGCNA]{plotDendroAndColors}}
#' @rdname module_stability
#' @export
#' @importFrom WGCNA sampledBlockwiseModules initProgInd matchLabels updateProgInd plotDendroAndColors
module_stability <- function(norm.exp, net, nRuns = 30) {

    expr <- t(norm.exp)
    net_type <- net$params$net_type
    SFTpower <- net$params$SFTpower
    cor_method <- net$params$cor_method
    module_merging_threshold <- net$params$module_merging_threshold

    if(net_type == "signed hybrid") {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "signed",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    } else if(net_type == "signed") {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "signed Nowick",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    } else {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "unsigned",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    }

    nGenes <- ncol(expr)

    # Define a matrix of labels for the original and all resampling runs
    labels <- matrix(0, nGenes, nRuns + 1)
    labels[, 1] <- mods0[[1]]$mods$colors

    # Relabel modules in each of the resampling runs so that full and reampled modules with best overlaps have
    # the same labels. This is achieved by the function matchLabels.
    pind <- WGCNA::initProgInd()
    for (r in 2:(nRuns+1))
    {
        labels[, r] <- WGCNA::matchLabels(mods0[[r-1]]$mods$colors, labels[, 1])
        pind <- WGCNA::updateProgInd((r-1)/nRuns, pind)
    }

    pdf(file = "module_stability.pdf", width=8, height=9)
    WGCNA::plotDendroAndColors(mods0[[1]]$mods$dendrograms[[1]],
                               labels,
                               c("Full data set", paste("Resampling", c(1:nRuns))),
                               main = "Gene dendrogram and module labels from resampled data sets",
                               autoColorHeight = FALSE, colorHeight = 0.65,
                               dendroLabels = FALSE, hang = 0.03, guideHang = 0.05,
                               addGuide = TRUE, guideAll = FALSE,
                               cex.main = 1.2, cex.lab = 0.9, cex.colorLabels = 0.8,
                               marAll = c(0, 5, 3, 0))
    dev.off()
}

#' Correlate module eigengenes to trait
#'
#' @param exp Gene expression data frame used to reconstruct the network, with gene IDs as row names and sample names as column names.
#' @param metadata A 2-column trait data frame containing sample names in the first column and sample descriptions in the second column.
#' @param MEs Module eigengenes. It is the 2nd element of the result list generated by the function \code{exp2net}.
#' @param cor_method Method to calculate correlation. One of 'pearson', 'spearman' or 'kendall'. Default is 'spearman'.
#' @param transpose Logical indicating whether to transpose the heatmap of not. Default is FALSE.
#' @param palette RColorBrewer's color palette to use. Default is "RdYlBu", a palette ranging from blue to red.
#' @param continuous_trait Logical indicating if trait is a continuous variable. Default is FALSE.
#' @param cex.lab.x Font size for x axis labels. Default: 0.6.
#' @param cex.lab.y Font size for y axis labels. Default: 0.6.
#' @param cex.text Font size for numbers inside matrix. Default: 0.6.
#'
#' @return A heatmap showing the correlations between module eigengenes and trait with their associated significance levels.
#' @details Significance levels:
#' 1 asterisk: significant at alpha = 0.05.
#' 2 asterisks: significant at alpha = 0.01.
#' 3 asterisks: significant at alpha = 0.001.
#' no asterisk: not significant.
#'
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{corPvalueStudent}},\code{\link[WGCNA]{labeledHeatmap}},\code{\link[WGCNA]{blueWhiteRed}}
#' @rdname module_trait_cor
#' @export
#' @importFrom WGCNA corPvalueStudent labeledHeatmap blueWhiteRed
module_trait_cor <- function(exp, metadata, MEs, cor_method="spearman",
                             transpose=FALSE, palette="RdYlBu",
                             continuous_trait=FALSE,
                             cex.lab.x=0.6, cex.lab.y=0.6,
                             cex.text=0.6) {
    sampleinfo <- metadata[metadata[,1] %in% colnames(exp), ]

    if(!continuous_trait) {
        tablesamples <- table(sampleinfo)
        write.table(tablesamples, file="matrix.to.correlate.to.eigengenes.txt", quote=F, sep="\t", row.names=T)
        trait <- read.csv("matrix.to.correlate.to.eigengenes.txt", header=T, sep="\t", row.names=1, stringsAsFactors = FALSE)
        unlink("matrix.to.correlate.to.eigengenes.txt")
    } else {
        trait <- metadata
        rownames(trait) <- metadata[,1]
        trait[,1] <- NULL
    }

    modtraitcor <- cor(as.matrix(MEs), trait, use = "p", method=cor_method)
    nSamples <- ncol(exp)
    modtraitpvalue <- WGCNA::corPvalueStudent(modtraitcor, nSamples)
    modtraitsymbol <- modtraitpvalue
    modtraitsymbol[modtraitsymbol < 0.001] <- "***"
    modtraitsymbol[modtraitsymbol >= 0.001 & modtraitsymbol < 0.01] <- "**"
    modtraitsymbol[modtraitsymbol >= 0.01 & modtraitsymbol < 0.05] <- "*"
    modtraitsymbol[modtraitsymbol >= 0.05] <- ""


    textMatrix <- paste(signif(modtraitcor, 2), modtraitsymbol, sep = "")
    dim(textMatrix) <- dim(modtraitcor)
    par(mar = c(6, 8.5, 3, 3))

    if(transpose) {
        #Transpose the matrices
        modtraitcor <- t(modtraitcor)
        textMatrix <- t(textMatrix)
        ME.trait.cor <- WGCNA::labeledHeatmap(Matrix = modtraitcor,
                                              yLabels = colnames(trait),
                                              xLabels = names(MEs),
                                              xSymbols = names(MEs),
                                              xColorLabels = TRUE,
                                              yColorLabels = FALSE,
                                              colorLabels = FALSE,
                                              colors = colorRampPalette(rev(RColorBrewer::brewer.pal(10, palette)))(100),
                                              textMatrix = textMatrix,
                                              setStdMargins = FALSE,
                                              cex.text = cex.text,
                                              cex.lab.x = cex.lab.x,
                                              cex.lab.y = cex.lab.y,
                                              zlim = c(-1,1),
                                              main = paste("Module-trait relationships"))
    } else {
        ME.trait.cor <- WGCNA::labeledHeatmap(Matrix = modtraitcor,
                                              xLabels = colnames(trait),
                                              yLabels = names(MEs),
                                              ySymbols = names(MEs),
                                              colorLabels = FALSE,
                                              colors = colorRampPalette(rev(RColorBrewer::brewer.pal(10, palette)))(100),
                                              textMatrix = textMatrix,
                                              setStdMargins = FALSE,
                                              cex.text = cex.text,
                                              cex.lab.y = cex.lab.y,
                                              cex.lab.x = cex.lab.x,
                                              zlim = c(-1,1),
                                              main = paste("Module-trait relationships"))

    }
    return(ME.trait.cor)
}

#' Calculate gene significance for a given group of genes
#'
#' @param exp Data frame of gene expression with gene IDs in row names and sample names in column names.
#' @param metadata Data frame containing sample names on the first column and sample information on the second column.
#' @param alpha Significance level. Default is 0.05.
#' @param min_cor Minimum correlation coefficient. Default is 0, which excludes negative correlations.
#' @param use_abs Logical indicating whether to filter by correlation using absolute value or not. If TRUE, a \code{min_cor} of say 0.4 would keep all correlations above 0.4 and below -0.4. Default is TRUE.
#' @param savetofile Logical indicating whether to save the table to correlations and p-values to a tab-delimited file or not.
#' @param palette RColorBrewer's color palette to use. Default is "RdYlBu", a palette ranging from blue to red.
#' @param show_rownames Logical indicating whether to show row names or not. Default is FALSE.
#' @param continuous_trait Logical indicating if trait is a continuous variable. Default is FALSE.
#'
#' @return A heatmap of gene significance (GS) and a list containing filtered and raw GS.
#' @seealso
#'  \code{\link[reshape2]{melt}}
#'  \code{\link[WGCNA]{corPvalueStudent}}
#'  \code{\link[RColorBrewer]{RColorBrewer}}
#' @rdname gene_significance
#' @export
#' @importFrom reshape2 melt
#' @importFrom WGCNA corPvalueStudent
#' @importFrom ComplexHeatmap pheatmap
#' @importFrom RColorBrewer brewer.pal
gene_significance <- function(exp, metadata, alpha = 0.05, min_cor = 0,
                              use_abs = TRUE, savetofile = FALSE,
                              palette="RdYlBu", show_rownames=FALSE,
                              continuous_trait=FALSE) {

    final_exp <- exp[, colnames(exp) %in% metadata[,1]]

    if(!continuous_trait) {
        tablesamples <- table(metadata)
        write.table(tablesamples, file="matrix.to.correlate.to.genes.txt", quote=F,
                    sep="\t", row.names=TRUE)
        trait <- read.csv("matrix.to.correlate.to.genes.txt", header=T, sep="\t", row.names=1, stringsAsFactors = FALSE)
        unlink("matrix.to.correlate.to.genes.txt")
    } else {
        trait <- metadata
        rownames(trait) <- metadata[,1]
        trait[,1] <- NULL
    }
    GS <- cor(as.matrix(t(final_exp)), trait, use = "p")

    # Filter by correlation coefficient and p-value
    melt.cor <- reshape2::melt(GS)
    nSamples <- ncol(final_exp)

    GS.pvalue <- WGCNA::corPvalueStudent(GS, nSamples)
    melt.pvalue <- reshape2::melt(GS.pvalue)

    corandp <- merge(melt.cor, melt.pvalue, by = c("Var1", "Var2"))
    corandp$Var1 <- as.character(corandp$Var1) # Convert gene names to character vectors
    corandp$Var2 <- as.character(corandp$Var2) # Convert sample descriptions to character vectors

    colnames(corandp) <- c("Gene", "Sample_info", "Cor", "pval")

    if(use_abs) {
        corandp <- corandp[corandp$pval < alpha & abs(corandp$Cor) > min_cor, ]
    } else {
        corandp <- corandp[corandp$pval < alpha & corandp$Cor > min_cor, ]
    }

    if(savetofile) {
        write.table(corandp, file = "gene_correlation_to_trait_and_pvalue.txt",
                    sep = "\t", row.names = FALSE, quote = FALSE)
    }

    ComplexHeatmap::pheatmap(as.matrix(GS),
                             color=colorRampPalette(RColorBrewer::brewer.pal(10, palette))(100),
                             show_rownames=show_rownames, main="Gene-trait correlations")

    resultlist <- list(filtered_corandp = corandp, raw_GS = GS)
    return(resultlist)
}


#' Get hub genes in a given module or in all modules at once
#'
#' @param exp Gene expression data frame with gene IDs as row names and sample names as column names.
#' @param net List object returned by \code{exp2net}.
#'
#' @return Data frame containing gene IDs, modules and intramodular connectivity of all hubs.
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{signedKME}}
#' @rdname get_hubs
#' @export
#' @importFrom WGCNA signedKME
#' @importFrom dplyr filter
get_hubs <- function(exp, net) {

    cor_method <- net$params$cor_method
    genes_modules <- net$genes_and_modules
    MEs <- net$MEs
    kIN <- net$kIN

    # List of genes and modules. Each element of the list is a module
    l1 <- split(genes_modules, f = genes_modules[,2])
    l1$grey <- NULL


    # Add kWithin info to each data frame in the list.
    l2 <- lapply(l1, function(x) merge(x, kIN, by.x = "Genes", by.y = "row.names"))

    # Calculate kME
    if (cor_method == "spearman") {
        MM <- WGCNA::signedKME(t(exp), MEs, corOptions = "use = 'p', method = 'spearman'")
    } else if (cor_method == "pearson") {
        MM <- WGCNA::signedKME(t(exp), MEs)
    } else {
        stop("Invalid correlation method. Pick one of 'spearman' or 'pearson'.")
    }

    # Add kME info to each data frame in the list
    l3 <- lapply(l2, function(x) merge(x, MM, by.x = "Genes", by.y="row.names"))

    # Keep only top 10% degree genes
    l4 <- lapply(l3, function(x) x[order(x$kWithin, decreasing = TRUE), ][1:round(nrow(x) * 0.1), ])

    # Remove 'kME' from colnames
    l5 <- lapply(l4, function(x) {
        colnames(x) <- gsub("kME", "", colnames(x))
        return(x)
    })

    # Pick genes from the top 10% degree with kME above 0.8
    final_list <- lapply(l5, function(x) {
        y <- unique(x$Modules)
        z <- dplyr::filter(x, y >= 0.8)
        z <- z[, c(1,2,4)]
        return(z)
    })

    hubs_df <- do.call(rbind, final_list)
    rownames(hubs_df) <- seq_len(nrow(hubs_df))
    colnames(hubs_df) <- c("Gene", "Module", "kWithin")
    return(hubs_df)
}

#' Helper function to perform Fisher's Exact Test with parallel computing
#'
#' @param genes Character vector containing genes on which enrichment will be tested.
#' @param reference Character vector containing genes to be used as background
#' @param genesets List of functional annotation categories (e.g., GO, pathway, etc.) with their associated genes.
#' @param adj Multiple testing correction method
#' @noRd
#' @return Results of Fisher's Exact Test in a data frame with TermID, number of associated genes, number of genes in reference set, P-value and adjusted P-value.
#' @importFrom stats p.adjust fisher.test
#' @importFrom BiocParallel bplapply
par_enrich <- function(genes, reference, genesets, adj = "BH") {
    reference <- reference[!reference %in% genes]

    tab <- BiocParallel::bplapply(seq_along(genesets), function(i) {

        RinSet <- sum(reference %in% genesets[[i]])
        RninSet <- length(reference) - RinSet
        GinSet <- sum(genes %in% genesets[[i]])
        GninSet <- length(genes) - GinSet
        fmat <- matrix(c(GinSet, RinSet, GninSet, RninSet), nrow = 2,
                       ncol = 2, byrow = FALSE)
        colnames(fmat) <- c("inSet", "ninSet")
        rownames(fmat) <- c("genes", "reference")
        fish <- stats::fisher.test(fmat, alternative = "greater")
        pval <- fish$p.value
        inSet <- RinSet + GinSet
        res <- c(GinSet, inSet, pval)
        return(res)
    })
    rtab <- do.call(rbind, tab)
    rtab <- data.frame(as.vector(names(genesets)), rtab)
    rtab <- rtab[order(rtab[, 4]), ]
    colnames(rtab) <- c("TermID", "genes", "all", "pval")
    padj <- stats::p.adjust(rtab$pval, method = adj)
    tab.out <- data.frame(rtab, padj)

    return(tab.out)
}


#' Perform enrichment analysis for a set of genes
#'
#' Perform enrichment analysis for functional annotation such as Gene Ontology (GO), pathway (KEGG, MapMan) or protein domains (PFAM, Panther).
#'
#' @param genes Character vector containing genes for overrepresentation analysis.
#' @param background_genes Character vector of genes to be used as background for the Fisher's Exact Test.
#' @param annotation Annotation data frame with genes in the first column and functional annotation in the other columns, which can be exported from Biomart or similar databases.
#' @param column Column or columns of  \code{annotation} to be used for enrichment. Both character or numeric values with column indices can be used. If users want to supply more than one column, input a character or numeric vector. Default: all columns from \code{annotation}.
#' @param correction Multiple testing correction method. One of "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr" or "none". Default is "BH".
#' @param p P-value threshold. P-values below this threshold will be considered significant. Default is 0.05.
#'
#' @return Data frame contaning significant terms, p-values and associated genes
#' @author Fabricio Almeida-Silva
#' @rdname enrichment_analysis
#' @export
#' @importFrom BiocParallel bplapply
enrichment_analysis <- function(genes, background_genes, annotation, column = NULL,
                                correction = "BH", p = 0.05) {

    ## Get a dataframe of expressed genes and their annotations
    gene_column <- colnames(annotation)[1]

    # Handle missing values
    annotation[is.na(annotation)] <- "Unannotated"

    if(is.null(column)) { #all columns?
        gene_annotation <- annotation
    } else {
        if(is.numeric(column)) { # Input is column indices
            gene_annotation <- annotation[, c(1, column)]
        } else { #Input is column names
            gene_annotation <- annotation[, c(paste(gene_column), column)]
        }
    }

    background <- gene_annotation[gene_annotation[,1] %in% background_genes, ]

    if(ncol(background) == 2) { #only one annotation category
        # Named list of expressed genes and their annotations
        annotation_list <- split(background[,1], background[,2])

        # Perform the enrichment analysis
        enrich.table <- par_enrich(genes, background_genes, annotation_list, adj = correction)
        signif_enrich <- as.data.frame(enrich.table[enrich.table$padj < p, ], stringsAsFactors = FALSE)

        if(nrow(signif_enrich) > 0) {
            signif_terms_genes <- annotation_list[as.character(signif_enrich[,1])]
            signif_terms_genes <- lapply(signif_terms_genes, function(x) unique(x[x %in% genes]))

            # Save final result with a column containing gene IDs of associated genes
            signif_enrich$GeneID <- unlist(lapply(signif_terms_genes,
                                                  paste, collapse = ","))
            df_signif_enrich <- signif_enrich
        } else {
            df_signif_enrich <- NULL
        }

    } else { # more than 1 annotation category
        annotation_list <- lapply(2:ncol(background), function(x) {
            return(split(background[,1], background[,x]))
        })

        # Remove unannotated genes
        annotation_list_final <- lapply(annotation_list, function(x) {
            return(x[names(x) != "Unannotated"])
        })

        # Perform the enrichment analysis
        signif_enrich <- BiocParallel::bplapply(annotation_list_final, function(x) {
            enrich.table <- par_enrich(genes, background_genes, x, adj=correction)
            sig_enrich <- as.data.frame(enrich.table[enrich.table$padj < p, ], stringsAsFactors=FALSE)
            return(sig_enrich)
        })

        # Remove empty data frames from list
        signif_enrich <- signif_enrich[sapply(signif_enrich, nrow) > 0]

        if(length(signif_enrich) > 0) {

            # Create a data frame containing annotations and the annotation class
            annot_correspondence <- Reduce(rbind, lapply(2:length(background), function(x) {
                annot_correspondence <- data.frame(TermID = background[,x],
                                                   Category = names(background)[x],
                                                   stringsAsFactors = FALSE)
                annot_correspondence <- annot_correspondence[!duplicated(annot_correspondence[,c(1,2)]),]
                return(annot_correspondence)
            }))

            # Add column containing the annotation class
            list_signif_enrich <- BiocParallel::bplapply(signif_enrich, function(x) {
                merge(x, annot_correspondence)
            })

            # Reduce list of data frames to a single data frame
            df_signif_enrich <- Reduce(rbind, list_signif_enrich)

            # Get genes associated to each term
            annotation_list_concat <- unlist(annotation_list, recursive = FALSE) # create list from list of lists
            signif_terms_genes <- annotation_list_concat[as.character(df_signif_enrich[,1])]
            signif_terms_genes <- lapply(signif_terms_genes, function(x) unique(x[x %in% genes]))

            # Get final table with enriched terms and a column containing the associated genes
            df_signif_enrich$GeneID <- unlist(lapply(signif_terms_genes,
                                                     paste, collapse = ","))

        } else {
            df_signif_enrich <- NULL
        }
    }
    return(df_signif_enrich)
}


#' Perform enrichment analysis for coexpression network modules
#'
#' Perform functional enrichment analysis for all coexpression network modules.
#'
#' @param net List object returned by \code{exp2net}.
#' @param background_genes Character vector of genes to be used as background for the Fisher's Exact Test.
#' @param annotation Annotation data frame with genes in the first column and functional annotation in the other columns, which can be exported from Biomart or similar databases.
#' @param column Column or columns of  \code{annotation} to be used for enrichment. Both character or numeric values with column indices can be used. If users want to supply more than one column, input a character or numeric vector. Default: all columns from \code{annotation}.
#' @param correction Multiple testing correction method. One of "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr" or "none". Default is "BH".
#' @param p P-value threshold. P-values below this threshold will be considered significant. Default is 0.05.
#'
#' @return A data frame containing enriched terms, p-values, gene IDs and module names.
#' @author Fabricio Almeida-Silva
#' @rdname module_enrichment
#' @importFrom BiocParallel bplapply
#' @export
#'
module_enrichment <- function(net=NULL, background_genes, annotation, column = NULL,
                              correction = "BH", p = 0.05) {

    # Divide modules in different data frames of a list
    genes.modules <- net$genes_and_modules
    list.gmodules <- split(genes.modules, genes.modules$Modules)
    list.gmodules <- list.gmodules[names(list.gmodules) != "grey"]

    enrichment_allmodules <- BiocParallel::bplapply(seq_along(list.gmodules), function(x) {
        message("Enrichment analysis for module ", names(list.gmodules)[x],
                "...")

        l <- enrichment_analysis(genes = as.character(list.gmodules[[x]][,1]),
                                 background_genes = background_genes,
                                 annotation = annotation,
                                 correction = correction, p = p)
        return(l)
    })
    names(enrichment_allmodules) <- names(list.gmodules)

    # Remove NULL elements from list
    enrichment_filtered <- enrichment_allmodules[!sapply(enrichment_allmodules,
                                                         is.null)]

    if(length(enrichment_filtered) == 0) {
        message("None of the modules had significant enrichment.")
        enrichment_final <- NULL
    } else {
        # Add module name to each data frame
        enrichment_modnames <- lapply(seq_along(enrichment_filtered), function(x) {
            return(cbind(enrichment_filtered[[x]],Module=names(enrichment_filtered)[x]))
        })

        # Reduce list of data frames to a single data frame
        enrichment_final <- Reduce(rbind, enrichment_modnames)
    }

    return(enrichment_final)
}

#' Get 1st-order neighbors of a given gene or group of genes
#'
#' @param genes Character vector containing genes from which direct neighbors will be extracted.
#' @param net List object returned by \code{exp2net}.
#' @param cor_threshold Correlation threshold to filter connections. As a weighted network is a fully connected graph, a cutoff must be selected. Default is 0.7.
#'
#' @return List containing 1st-order neighbors for each input gene.
#'
#' @seealso \code{exp2net} \code{SFT_fit}
#' @author Fabricio Almeida-Silva
#' @export
#'
#' @rdname get_neighbors
get_neighbors <- function(genes, net, cor_threshold = 0.7) {

    net_type <- net$params$net_type
    power <- net$params$SFTpower
    edges <- net$adjacency_matrix

    edges[lower.tri(edges, diag = TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges)), stringsAsFactors = FALSE);
    colnames(edges) <- c("Gene1", "Gene2", "Weight")

    if(net_type == "signed") {
        adj_threshold <- (0.5*(1 - cor_threshold))^power
    } else if(net_type == "signed hybrid") {
        if(cor_threshold > 0) {
            adj_threshold <- cor_threshold^power
        } else {
            stop("Negative correlation chosen as threshold. Signed hybrid networks don't have negative values.")
        }
    } else if(net_type == "unsigned") {
        adj_threshold <- abs(cor_threshold)^power
    } else {
        stop("Please, specify a network type. One of 'signed', 'signed hybrid' or 'unsigned'.")
    }

    filt_edges <- edges[edges$Gene1 %in% genes | edges$Gene2 %in% genes, ]
    filt_edges <- filt_edges[filt_edges$Weight >= adj_threshold, ]

    list <- sapply(genes, function(x) {
        y <- filt_edges[rowSums(filt_edges == x) > 0, ]
        y <- c(as.character(y$Gene1), as.character(y$Gene2))
        y <- unique(y[y != x])
        y
    })
    return(list)
}


#' Get edge list from an adjacency matrix for a group of genes
#'
#' @param net List object returned by \code{exp2net}.
#' @param genes Character vector containing a subset of genes from which edges will be extracted. It can be ignored if the user wants to extract an edge list for a given module instead of individual genes.
#' @param module Character with module name from which edges will be extracted. To include 2 or more modules, input the names in a character vector.
#' @param filter Logical indicating whether to filter the edge list or not.
#' @param method Method to filter spurious correlations. One of "Zscore", "optimalSFT", "pvalue" or "min_cor". See details for more information on the methods. Default: 'optimalSFT'
#' @param r_optimal_test Numeric vector with the correlation thresholds to be tested for optimal scale-free topology fit. Only valid if \code{method} equals "optimalSFT". Default: seq(0.4, 0.9, by = 0.1)
#' @param Zcutoff Minimum Z-score threshold. Only valid if \code{method} equals "Zscore". Default: 1.96
#' @param pvalue_cutoff Maximum P-value threshold. Only valid if \code{method} equals "pvalue". Default: 0.05
#' @param rcutoff Minimum correlation threshold. Only valid if \code{method} equals "min_cor". Default: 0.7
#' @param nSamples Number of samples in the dataset from which the correlation matrix was calculated. Only required if \code{method} equals "pvalue".
#' @param check_SFT Logical indicating whether to test if the resulting network is scale-free or not. Default: FALSE
#'
#' @return Data frame with edge list for the input genes.
#' @details The default method ("optimalSFT") will create several different edge lists by filtering the original correlation matrix by the thresholds specified in \code{r_optimal_test}. Then, it will calculate a scale-free topology fit index for each of the possible networks and return the network that best fits the scale-free topology.
#' The method "Zscore" will apply a Fisher Z-transformation for the correlation coefficients and remove the Z-scores below the threshold specified in \code{Zcutoff}.
#' The method "pvalue" will calculate Student asymptotic p-value for the correlations and remove correlations whose p-values are above the threshold specified in \code{pvalue_cutoff}.
#' The method "min_cor" will remove correlations below the minimum correlation threshold specified in \code{rcutoff}.
#' @seealso
#'  \code{\link[WGCNA]{scaleFreeFitIndex}},\code{\link[WGCNA]{corPvalueStudent}}
#'  \code{\link[igraph]{fit_power_law}}
#' @seealso \code{SFT_fit}
#' @seealso \code{exp2net}.
#' @author Fabricio Almeida-Silva
#' @rdname get_edge_list
#' @export
#' @importFrom WGCNA scaleFreeFitIndex corPvalueStudent
#' @importFrom ggpubr ggline
#' @importFrom ggplot2 theme element_text
#' @importFrom BiocParallel bplapply
get_edge_list <- function(net, genes = NULL, module = NULL,
                          filter = FALSE, method = "optimalSFT",
                          r_optimal_test = seq(0.4, 0.9, by=0.1),
                          Zcutoff = 1.96, pvalue_cutoff = 0.05, rcutoff = 0.7,
                          nSamples = NULL,
                          check_SFT = FALSE) {

    # Define objects containing correlation matrix and data frame of genes and modules
    cor_matrix <- net$correlation_matrix

    # Should we extract genes in a module?
    if(!is.null(module)) {
        genes_modules <- net$genes_and_modules
        keep <- genes_modules[genes_modules$Modules %in% module, 1]
        cor_matrix <- cor_matrix[keep, keep]
    }

    # Should we extract a user-defined gene set?
    if(!is.null(genes)) {
        cor_matrix <- cor_matrix[genes, genes]
    }

    # Should we filter the matrix?
    if(filter) {
        # Create edge list from correlation matrix
        edges <- cormat_to_edgelist(cor_matrix)
        colnames(edges) <- c("Gene1", "Gene2", "Weight")

        if(method == "Zscore") {
            # Apply Fisher-Z transformation to correlation values
            edgesZ <- edges
            edgesZ$Weight <- 0.5 * log((1+edges$Weight) / (1-edges$Weight))

            edgelist <- edgesZ[edgesZ$Weight >= Zcutoff, ]
        } else if(method == "optimalSFT") {
            cutoff <- r_optimal_test

            # Create list of 2 elements: edge lists, each with a different correlation threshold, and degree
            list_mat <- replicate(length(cutoff), cor_matrix, simplify = FALSE)

            list_cormat_filtered <- BiocParallel::bplapply(seq_along(list_mat), function(x) {
                # Convert r values below threshold to NA and set diagonals to 0
                matrix <- list_mat[[x]]
                matrix[matrix < cutoff[x] ] <- NA
                diag(matrix) <- 0

                # Calculate degree
                degree <- rowSums(matrix, na.rm=TRUE)

                # Convert lower triangle and diagonals to NA
                matrix[lower.tri(matrix, diag=TRUE)] <- NA

                # Convert symmetrical matrix to edge list (Gene1, Gene2, Weight)
                matrix <- na.omit(data.frame(as.table(matrix), stringsAsFactors=FALSE))
                result <- list(matrix=matrix, degree=degree)
                return(result)
            })

            degree_list <- lapply(list_cormat_filtered, function(x) return(x[[2]]))

            # Calculate scale-free topology
            sft.rsquared <- unlist(lapply(degree_list, function(x) WGCNA::scaleFreeFitIndex(x)$Rsquared.SFT))
            max.index <- which.max(sft.rsquared)

            # Plot scale-free topology fit for r values
            plot.data <- data.frame(x=cutoff, y=sft.rsquared, stringsAsFactors = FALSE)
            plot <- ggpubr::ggline(plot.data, x = "x", y = "y", size=2,
                                   color="firebrick",
                                   xlab = "Correlation (r) values",
                                   ylab = expression(paste("Scale-free topology fit - ", R^{2})),
                                   title = "Scale-free topology fit for given r values", font.title = c(13, "bold")) +
                ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))
            print(plot)


            optimalr <- cutoff[max.index]
            message("The correlation threshold that best fits the scale-free topology is ", optimalr)

            edgelist <- list_cormat_filtered[[max.index]][[1]]

        } else if(method == "pvalue") {
            if(is.null(nSamples)) {
                stop("Please, specify the number of samples used to calculate the correlation matrix")
            }

            # Calculate Student asymptotic p-value for given correlations
            cor.pvalue <- WGCNA::corPvalueStudent(edges$Weight, nSamples)

            # Create a data frame of correlations and p-values
            corandp <- edges
            corandp$pvalue <- cor.pvalue

            # Create a final edge list containing only significant correlations
            edgelist <- corandp[corandp$pvalue < pvalue_cutoff, c(1:3)]

        } else if(method == "min_cor") {
            edgelist <- edges[edges$Weight >= rcutoff, ]

        } else{
            stop("Please, specify a valid filtering method.")
        }

    } else {
        # Create edge list from correlation matrix without filtering
        edgelist <- cormat_to_edgelist(cor_matrix)
        colnames(edgelist) <- c("Gene1", "Gene2", "Weight")
    }

    # Check scale-free topology fit
    if(check_SFT) {
        test <- check_sft(edgelist, net_type="gcn")
    }

    return(edgelist)
}

#' Pick power to fit network to a scale-free topology
#'
#' @param exp Normalized expression table, where rownames are gene IDs and colnames are sample names
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'. Default is signed.
#' @param rsquared R squared cutoff. Default is 0.8.
#' @param cor_method Correlation method. One of "pearson", "biweight" or "spearman". Default is "spearman".
#'
#' @return Power to fit network to a scale-free topology and SFT fit plots in PDF in the user's working directory
#'
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{pickSoftThreshold}}
#' @rdname SFT_fit
#' @export
#' @importFrom WGCNA pickSoftThreshold
SFT_fit <- function(exp, net_type="signed", rsquared=0.8, cor_method="spearman") {
    texp <- t(exp)

    if(cor_method == "pearson") {
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20, RsquaredCut = rsquared)
    } else if(cor_method == "biweight") {
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20,
                                        RsquaredCut = rsquared, corFnc = bicor, corOptions = list(use = 'p', maxPOutliers = 0.05))
    } else if (cor_method == "spearman"){
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20,
                                        RsquaredCut = rsquared, corOptions = list(use = 'p', method = "spearman"))
    } else {
        print("Please, specify a correlation method (one of 'spearman', 'pearson' or 'biweight').")
    }
    wgcna_power <- sft$powerEstimate
    if(is.na(wgcna_power)){
        print(paste("No power reached R-squared cut-off, now choosing max R-squared based power"))
        wgcna_power <- sft$fitIndices$Power[which(sft$fitIndices$SFT.R.sq == max(sft$fitIndices$SFT.R.sq))]
    }
    pdf(file = "SFT and power beta selection.pdf", width=12, height=9)
    par(mfrow = c(1,2));
    plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit, signed R^2",type="n",
         main = paste("Scale independence"), ylim=c(0,1));
    text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         labels=1:20,cex=0.9,col="black");
    abline(h=0.80,col="red")
    plot(sft$fitIndices[,1], sft$fitIndices[,5], main = paste("Mean connectivity"), xlab="Soft Threshold (power)", ylab="Mean connectivity (k)")
    text(sft$fitIndices[,1], sft$fitIndices[,5], labels=1:20, cex=0.9,col="red")
    dev.off()

    return(wgcna_power)
}


#' Reconstruct gene coexpression network from gene expression data frame
#'
#' @param norm.exp Normalized gene expression data frame, where row names are gene IDs and column names are sample names.
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'.
#' @param module_merging_threshold Maximum dissimilarity (1-cor) between module for module merging. As it is based on dissimilarity, a threshold of 0.2 means that module eigengenes must be at least 0.8 similar to be merged. Default is 0.2.
#' @param SFTpower SFT power generated by the function \code{SFT_fit}.
#' @param cor_method Correlation method. One of "pearson", "biweight" or "spearman". Default is "spearman", considering that the expression data does not follow a normal distribution.
#'
#' @return List containing: \itemize{
#'   \item Adjacency matrix
#'   \item Data frame of module eigengenes
#'   \item Data frame of genes and their corresponding modules
#'   \item Data frame of intramodular connectivity
#'   \item Vector of module assignment
#'   \item Correlation matrix
#'   \item Parameters used for network reconstruction
#' }
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{adjacency.fromSimilarity}},\code{\link[WGCNA]{TOMsimilarity}},\code{\link[WGCNA]{standardColors}},\code{\link[WGCNA]{labels2colors}},\code{\link[WGCNA]{moduleEigengenes}},\code{\link[WGCNA]{plotEigengeneNetworks}},\code{\link[WGCNA]{mergeCloseModules}},\code{\link[WGCNA]{plotDendroAndColors}},\code{\link[WGCNA]{intramodularConnectivity}}
#'  \code{\link[dynamicTreeCut]{cutreeDynamicTree}}
#' @rdname exp2net
#' @export
#' @importFrom WGCNA adjacency.fromSimilarity TOMsimilarity standardColors labels2colors moduleEigengenes plotEigengeneNetworks mergeCloseModules plotDendroAndColors intramodularConnectivity
#' @importFrom dynamicTreeCut cutreeDynamicTree
exp2net <- function(norm.exp, net_type="signed hybrid", module_merging_threshold = 0.2,
                    SFTpower, cor_method = "spearman") {

  params <- list(net_type=net_type,
                 module_merging_threshold=module_merging_threshold,
                 SFTpower=SFTpower,
                 cor_method=cor_method)

  if(is.null(SFTpower)) {
    stop("Please, specify the SFT power")
  }

    print("Calculating adjacency matrix...")
    if(cor_method == "pearson") {
      cor_matrix <- cor(t(norm.exp), method = "pearson")
      adj_matrix <- WGCNA::adjacency.fromSimilarity(cor_matrix, power = SFTpower, type=net_type)
    } else if(cor_method == "spearman") {
      cor_matrix <- cor(t(norm.exp), use="p", method = "spearman")
      adj_matrix <- WGCNA::adjacency.fromSimilarity(cor_matrix, power=SFTpower, type=net_type)
    } else if (cor_method == "biweight") {
      cor_matrix <- WGCNA::bicor(t(norm.exp), maxPOutliers = 0.1)
      adj_matrix <- WGCNA::adjacency.fromSimilarity(cor_matrix, power=SFTpower, type=net_type)
    } else {
      stop("Please, specify a correlation method. One of 'spearman', 'pearson' or 'biweight'.")
    }
    print("Removing diagonals...")
    diag(adj_matrix) <- 0

    #Convert to matrix
    gene_ids <- rownames(adj_matrix)
    adj_matrix <- matrix(adj_matrix, nrow=nrow(adj_matrix))
  rownames(adj_matrix) <- gene_ids
    colnames(adj_matrix) <- gene_ids

    #Calculate TOM from adjacency matrix
    print("Calculating topological overlap matrix (TOM)...")
    if(net_type == "signed hybrid") {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "signed")
    } else if(net_type == "signed") {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "signed Nowick")
    } else {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "unsigned")
    }


    #Hierarchically cluster genes
    dissTOM <- 1-TOM #hclust takes a distance structure
    geneTree <- hclust(as.dist(dissTOM), method="average")

    #Detecting coexpression modules
    print("Detecting coexpression modules...")
    old.module_labels <- dynamicTreeCut::cutreeDynamicTree(dendro=geneTree, minModuleSize=30,
                                                           deepSplit=TRUE)

    nmod <- length(unique(old.module_labels))
    palette <- rev(WGCNA::standardColors(nmod))
    old.module_colors <- WGCNA::labels2colors(old.module_labels, colorSeq = palette)

    #Calculate eigengenes and merge the ones who are highly correlated
    print("Calculating module eigengenes (MEs)...")
    old.MElist <- WGCNA::moduleEigengenes(t(norm.exp), colors = old.module_colors, softPower = SFTpower)
    old.MEs <- old.MElist$eigengenes

    #Calculate dissimilarity of module eigengenes
    MEDiss1 <- 1-cor(old.MEs)

    #Hierarchically cluster module eigengenes to see how they're related
    old.METree <- hclust(as.dist(MEDiss1), method="average")

    #Then, choose a height cut.
    MEDissThreshold <- module_merging_threshold

    #Merge the modules.
    print("Merging similar modules...")
    if(cor_method == "pearson") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3)
    } else if(cor_method == "spearman") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, corOptions = list(use = "p", method = "spearman"))
    } else if(cor_method == "biweight") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, corFnc = bicor)
    } else {
        print("Please, specify a correlation method. One of 'spearman', 'pearson' or 'biweight'.")
    }
    new.module_colors <- merge1$colors
    new.MEs <- merge1$newMEs #calculate the eigengenes of new modules

    #Plot dendrogram of merged modules eigengenes
    new.METree <- hclust(as.dist(1-cor(new.MEs)), method="average")

    pdf(file = "Eigengene_network.pdf", width=9, height=9)
    eigennetwork_aftermerging <- WGCNA::plotEigengeneNetworks(new.MEs, "", marDendro=c(0,4,1,2), marHeatmap=c(3,4,1,2))
    dev.off()

    #See dendrogram with colors to analyze how old modules and merged modules differ
    pdf(file="Dendrogram_and_module_colors_before_and_after_merging.pdf", width = 9, height=9)
    dendroandcolors_comparison <- WGCNA::plotDendroAndColors(geneTree, cbind(old.module_colors, new.module_colors), c("Unmerged", "Merged"),
                                                             dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
    dev.off()

    #Get data frame with genes and modules they belong to
    genes_and_modules <- as.data.frame(cbind(gene_ids, new.module_colors), stringsAsFactors = FALSE)
    colnames(genes_and_modules) <- c("Genes", "Modules")

    print("Calculating intramodular connectivity...")
    intramodular_k_allmodules <- WGCNA::intramodularConnectivity(adj_matrix, new.module_colors)

    result.list <- list(adjacency_matrix = adj_matrix,
                        MEs = new.MEs,
                        genes_and_modules = genes_and_modules,
                        kIN = intramodular_k_allmodules,
                        moduleColors = new.module_colors,
                        correlation_matrix = cor_matrix,
                        params=params)

    return(result.list)
}

#' Perform module stability analysis
#'
#' @param norm.exp Normalized gene expression data frame, where row names are gene IDs and column names are sample names.
#' @param net List object returned by \code{exp2net}.
#' @param nRuns Number of times to resample. Default is 30.
#'
#' @return A .pdf file in the current working directory representing the module stability across the resamplings.
#' @seealso
#'  \code{\link[WGCNA]{sampledBlockwiseModules}},\code{\link[WGCNA]{matchLabels}},\code{\link[WGCNA]{plotDendroAndColors}}
#' @rdname module_stability
#' @export
#' @importFrom WGCNA sampledBlockwiseModules initProgInd matchLabels updateProgInd plotDendroAndColors
module_stability <- function(norm.exp, net, nRuns = 30) {

    expr <- t(norm.exp)
    net_type <- net$params$net_type
    SFTpower <- net$params$SFTpower
    cor_method <- net$params$cor_method
    module_merging_threshold <- net$params$module_merging_threshold

    if(net_type == "signed hybrid") {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "signed",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    } else if(net_type == "signed") {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "signed Nowick",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    } else {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "unsigned",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    }

    nGenes <- ncol(expr)

    # Define a matrix of labels for the original and all resampling runs
    labels <- matrix(0, nGenes, nRuns + 1)
    labels[, 1] <- mods0[[1]]$mods$colors

    # Relabel modules in each of the resampling runs so that full and reampled modules with best overlaps have
    # the same labels. This is achieved by the function matchLabels.
    pind <- WGCNA::initProgInd()
    for (r in 2:(nRuns+1))
    {
        labels[, r] = WGCNA::matchLabels(mods0[[r-1]]$mods$colors, labels[, 1])
        pind <- WGCNA::updateProgInd((r-1)/nRuns, pind)
    }

    pdf(file = "module_stability.pdf", wi=8, h=9)
    WGCNA::plotDendroAndColors(mods0[[1]]$mods$dendrograms[[1]],
                        labels,
                        c("Full data set", paste("Resampling", c(1:nRuns))),
                        main = "Gene dendrogram and module labels from resampled data sets",
                        autoColorHeight = FALSE, colorHeight = 0.65,
                        dendroLabels = FALSE, hang = 0.03, guideHang = 0.05,
                        addGuide = TRUE, guideAll = FALSE,
                        cex.main = 1.2, cex.lab = 0.9, cex.colorLabels = 0.8,
                        marAll = c(0, 5, 3, 0))
    dev.off()
}

#' Correlate module eigengenes to trait
#'
#' @param exp Gene expression data frame used to reconstruct the network, with gene IDs as row names and sample names as column names.
#' @param metadata A 2-column trait data frame containing sample names in the first column and sample descriptions in the second column.
#' @param MEs Module eigengenes. It is the 2nd element of the result list generated by the function \code{exp2net}.
#' @param cor_method Method to calculate correlation. One of 'pearson', 'spearman' or 'kendall'. Default is 'spearman'.
#' @param transpose Logical indicating whether to transpose the heatmap of not. Default is FALSE.
#' @param palette RColorBrewer's color palette to use. Default is "RdYlBu", a palette ranging from blue to red.
#' @param continuous_trait Logical indicating if trait is a continuous variable. Default is FALSE.
#'
#' @return A heatmap showing the correlations between module eigengenes and trait with their associated significance levels.
#' @details Significance levels:
#' 1 asterisk: significant at alpha = 0.05.
#' 2 asterisks: significant at alpha = 0.01.
#' 3 asterisks: significant at alpha = 0.001.
#' no asterisk: not significant.
#'
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{corPvalueStudent}},\code{\link[WGCNA]{labeledHeatmap}},\code{\link[WGCNA]{blueWhiteRed}}
#' @rdname module_trait_cor
#' @export
#' @importFrom WGCNA corPvalueStudent labeledHeatmap blueWhiteRed
module_trait_cor <- function(exp, metadata, MEs, cor_method="spearman",
                              transpose=FALSE, palette="RdYlBu",
                              continuous_trait=FALSE) {
  sampleinfo <- metadata[metadata[,1] %in% colnames(exp), ]

  if(continuous_trait == FALSE) {
    tablesamples <- table(sampleinfo)
    write.table(tablesamples, file="matrix.to.correlate.to.eigengenes.txt", quote=F, sep="\t", row.names=T)
    trait <- read.csv("matrix.to.correlate.to.eigengenes.txt", header=T, sep="\t", row.names=1, stringsAsFactors = FALSE)
    unlink("matrix.to.correlate.to.eigengenes.txt")
  } else {
    trait <- metadata
    rownames(trait) <- metadata[,1]
    trait[,1] <- NULL
  }

  modtraitcor <- cor(as.matrix(MEs), trait, use = "p", method=cor_method)
  nSamples <- ncol(exp)
  modtraitpvalue <- WGCNA::corPvalueStudent(modtraitcor, nSamples)
  modtraitsymbol <- modtraitpvalue
  modtraitsymbol[modtraitsymbol < 0.001] <- "***"
  modtraitsymbol[modtraitsymbol >= 0.001 & modtraitsymbol < 0.01] <- "**"
  modtraitsymbol[modtraitsymbol >= 0.01 & modtraitsymbol < 0.05] <- "*"
  modtraitsymbol[modtraitsymbol >= 0.05] <- ""


  textMatrix <- paste(signif(modtraitcor, 2), modtraitsymbol, sep = "")
  dim(textMatrix) <- dim(modtraitcor)
  par(mar = c(6, 8.5, 3, 3))

  if(transpose == TRUE) {
    #Transpose the matrices
    modtraitcor <- t(modtraitcor)
    textMatrix <- t(textMatrix)
    ME.trait.cor <- WGCNA::labeledHeatmap(Matrix = modtraitcor,
                                          yLabels = colnames(trait), xLabels = names(MEs),
                                          xSymbols = names(MEs),
                                          xColorLabels = TRUE, yColorLabels = FALSE,
                                          colorLabels=FALSE,
                                          colors=colorRampPalette(
                                            rev(RColorBrewer::brewer.pal(10, palette)))(100),
                                          textMatrix=textMatrix, setStdMargins = FALSE,
                                          cex.text = 0.6, zlim = c(-1,1),
                                          cex.lab.x = 0.7, main = paste("Module-trait relationships"))
  } else {
    ME.trait.cor <- WGCNA::labeledHeatmap(Matrix = modtraitcor,
                                          xLabels = colnames(trait), yLabels = names(MEs),
                                          ySymbols = names(MEs),
                                          colorLabels=FALSE,
                                          colors=colorRampPalette(
                                            rev(RColorBrewer::brewer.pal(10, palette)))(100),
                                          textMatrix=textMatrix, setStdMargins = FALSE,
                                          cex.text = 0.6, zlim = c(-1,1),
                                          cex.lab.y = 0.5, main = paste("Module-trait relationships"))

  }
}

#' Calculate gene significance for a given group of genes
#'
#' @param exp Data frame of gene expression with gene IDs in row names and sample names in column names.
#' @param metadata Data frame containing sample names on the first column and sample information on the second column.
#' @param alpha Significance level. Default is 0.05.
#' @param min_cor Minimum correlation coefficient. Default is 0, which excludes negative correlations.
#' @param use_abs Logical indicating whether to filter by correlation using absolute value or not. If TRUE, a \code{min_cor} of say 0.4 would keep all correlations above 0.4 and below -0.4. Default is TRUE.
#' @param savetofile Logical indicating whether to save the table to correlations and p-values to a tab-delimited file or not.
#' @param palette RColorBrewer's color palette to use. Default is "RdYlBu", a palette ranging from blue to red.
#' @param show_rownames Logical indicating whether to show row names or not. Default is FALSE.
#' @param continuous_trait Logical indicating if trait is a continuous variable. Default is FALSE.
#'
#' @return A heatmap of gene significance (GS) and a list containing filtered and raw GS.
#' @seealso
#'  \code{\link[reshape2]{melt}}
#'  \code{\link[WGCNA]{corPvalueStudent}}
#'  \code{\link[pheatmap]{pheatmap}}
#'  \code{\link[RColorBrewer]{RColorBrewer}}
#' @rdname gene_significance
#' @export
#' @importFrom reshape2 melt
#' @importFrom WGCNA corPvalueStudent
#' @importFrom pheatmap pheatmap
#' @importFrom RColorBrewer brewer.pal
gene_significance <- function(exp, metadata, alpha = 0.05, min_cor = 0,
                              use_abs = TRUE, savetofile = FALSE,
                              palette="RdYlBu", show_rownames=FALSE,
                              continuous_trait=FALSE) {

  final_exp <- exp[, colnames(exp) %in% metadata[,1]]

  if(continuous_trait == FALSE) {
    tablesamples <- table(metadata)
    write.table(tablesamples, file="matrix.to.correlate.to.genes.txt", quote=F,
                sep="\t", row.names=TRUE)
    trait <- read.csv("matrix.to.correlate.to.genes.txt", header=T, sep="\t", row.names=1, stringsAsFactors = FALSE)
    unlink("matrix.to.correlate.to.genes.txt")
  } else {
    trait <- metadata
    rownames(trait) <- metadata[,1]
    trait[,1] <- NULL
  }
  GS <- cor(as.matrix(t(final_exp)), trait, use = "p")

  # Filter by correlation coefficient and p-value
  melt.cor <- reshape2::melt(GS)
  nSamples <- ncol(final_exp)

  GS.pvalue <- WGCNA::corPvalueStudent(GS, nSamples)
  melt.pvalue <- reshape2::melt(GS.pvalue)

  corandp <- merge(melt.cor, melt.pvalue, by = c("Var1", "Var2"))
  corandp$Var1 <- as.character(corandp$Var1) # Convert gene names to character vectors
  corandp$Var2 <- as.character(corandp$Var2) # Convert sample descriptions to character vectors

  colnames(corandp) <- c("Gene", "Sample_info", "Cor", "pval")

  if(use_abs == TRUE) {
    corandp <- corandp[corandp$pval < alpha & abs(corandp$Cor) > min_cor, ]
  } else {
    corandp <- corandp[corandp$pval < alpha & corandp$Cor > min_cor, ]
  }

  if(savetofile == TRUE) {
    write.table(corandp, file = "gene_correlation_to_trait_and_pvalue.txt",
                sep = "\t", row.names = FALSE, quote = FALSE)
  }

  pheatmap::pheatmap(GS, color=colorRampPalette(RColorBrewer::brewer.pal(10, palette))(100),
                     show_rownames=show_rownames, main="Gene-trait correlations")

  resultlist <- list(filtered_corandp = corandp, raw_GS = GS)
  return(resultlist)
}


#' Get hub genes in a given module or in all modules at once
#'
#' @param exp Gene expression data frame with gene IDs as row names and sample names as column names.
#' @param net List object returned by \code{exp2net}.
#'
#' @return Data frame containing gene IDs, modules and intramodular connectivity of all hubs.
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{signedKME}}
#' @rdname get_hubs
#' @export
#' @importFrom WGCNA signedKME
#' @importFrom dplyr filter
get_hubs <- function(exp, net) {

  cor_method <- net$params$cor_method
  genes_modules <- net[[3]]
  MEs <- net[[2]]
  kIN <- net[[4]]

  # List of genes and modules. Each element of the list is a module
  l1 <- split(genes_modules, f = genes_modules[,2])
  l1$grey <- NULL


  # Add kWithin info to each data frame in the list.
  l2 <- lapply(l1, function(x) merge(x, kIN, by.x = "Genes", by.y = "row.names"))

  # Calculate kME
  if (cor_method == "spearman") {
    MM <- WGCNA::signedKME(t(exp), MEs, corOptions = "use = 'p', method = 'spearman'")
  } else if (cor_method == "pearson") {
    MM <- WGCNA::signedKME(t(exp), MEs)
  } else {
    print("Invalid correlation method. Pick one of 'spearman' or 'pearson'.")
  }

  # Add kME info to each data frame in the list
  l3 <- lapply(l2, function(x) merge(x, MM, by.x = "Genes", by.y="row.names"))

  # Keep only top 10% degree genes
  l4 <- lapply(l3, function(x) x[order(x$kWithin, decreasing = TRUE), ][1:round(nrow(x) * 0.1), ])

  # Remove 'kME' from colnames
  l5 <- lapply(l4, function(x) {
    colnames(x) <- gsub("kME", "", colnames(x))
    return(x)
  })

  # Pick genes from the top 10% degree with kME above 0.8
  final_list <- lapply(l5, function(x) {
    y <- unique(x$Modules)
    z <- dplyr::filter(x, y >= 0.8)
    z <- z[, c(1,2,4)]
    return(z)
  })

    hubs_df <- do.call(rbind, final_list)
    rownames(hubs_df) <- 1:nrow(hubs_df)
    colnames(hubs_df) <- c("Gene", "Module", "kWithin")
    return(hubs_df)
}


#' Perform enrichment analysis for a set of genes
#'
#' Perform enrichment analysis for functional annotation such as Gene Ontology (GO), pathway (KEGG, MapMan) or protein domains (PFAM, Panther).
#'
#' @param genes Character vector containing genes for overrepresentation analysis.
#' @param exp Data frame of expressed genes and their expression values across samples.Gene IDs must correspond to row names and column names represent sample names.
#' @param annotation Annotation data frame with genes in the first column and functional annotation in the other columns, which can be exported from Biomart or similar databases.
#' @param column Column or columns of  \code{annotation} to be used for enrichment. Both character or numeric values with column indices can be used. If users want to supply more than one column, input a character or numeric vector. Default: all columns from \code{annotation}.
#' @param correction Multiple testing correction method. One of "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr" or "none". Default is "BH".
#' @param p P-value threshold. P-values below this threshold will be considered significant. Default is 0.05.
#'
#' @return List containing two elements: \describe{
#'  \item{Significant_terms}{Data frame contaning significant terms and p-values}
#'  \item{Associated_genes}{List containing genes associated with each significant term}
#' }
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[bc3net]{enrichment}}
#' @rdname enrichment_analysis
#' @export
#' @importFrom bc3net enrichment
enrichment_analysis <- function(genes, exp, annotation, column = NULL,
                                correction = "BH", p = 0.05) {

    # Get a dataframe of expressed genes and their annotations
    background_genes <- rownames(exp)
    gene_column <- colnames(annotation)[1]

    # Handle missing values
    annotation[is.na(annotation)] <- "Unannotated"

    if(is.null(column)) { #all columns?
      gene_annotation <- annotation
    } else {
      if(is.numeric(column)) { # Input is column indices
        gene_annotation <- annotation[, c(1, column)]
      } else { #Input is column names
        gene_annotation <- annotation[, c(paste(gene_column), column)]
      }
    }

    background <- gene_annotation[gene_annotation[,1] %in% background_genes, ]

    if(ncol(background) == 2) { #only one annotation category
      # Named list of expressed genes and their annotations
      annotation_list <- split(background[,1], background[,2])

      # Perform the enrichment analysis
      enrich <- bc3net::enrichment(genes, background_genes, annotation_list, adj = correction)
      signif_enrich <- as.data.frame(enrich[enrich$padj < p, ], stringsAsFactors = FALSE)

      signif_terms_genes <- annotation_list[as.character(signif_enrich[,1])]
      signif_terms_genes <- lapply(signif_terms_genes, function(x) unique(x[x %in% genes]))

      final_list <- list(signif_enrich, signif_terms_genes);
      names(final_list) <- c("Significant_terms", "Associated_genes")

    } else { # more than 1 annotation category
      annotation_list <- lapply(2:ncol(background), function(x) {
        return(split(background[,1], background[,x]))
      })

      # Remove unannotated genes
      annotation_list_final <- lapply(annotation_list, function(x) {
        return(x[names(x) != "Unannotated"])
      })

      # Perform the enrichment analysis
      signif_enrich <- lapply(annotation_list_final, function(x) {
        enrich <- bc3net::enrichment(genes, background_genes, x, adj=correction)
        sig_enrich <- as.data.frame(enrich[enrich$padj < p, ], stringsAsFactors=FALSE)
        return(sig_enrich)
      })

      # Remove empty data frames from list
      signif_enrich <- signif_enrich[sapply(signif_enrich, nrow) > 0]

      # Create a data frame containing annotations and the annotation class
      #annot_correspondence <- list()
      annot_correspondence <- Reduce(rbind, lapply(2:length(background), function(x) {
        annot_correspondence <- data.frame(TermID = background[,x],
                                           Category = names(background)[x],
                                           stringsAsFactors = FALSE)
        return(annot_correspondence)
      }))


      if(length(signif_enrich) > 0) {
        # Add column containing the annotation class
        list_signif_enrich <- lapply(signif_enrich, function(x) {
          merge(x, annot_correspondence)
        })

        # Reduce list of data frames to a single data frame
        df_signif_enrich <- Reduce(rbind, list_signif_enrich)

        # Get genes associated to each term
        annotation_list_concat <- unlist(annotation_list, recursive = FALSE) # create list from list of lists
        signif_terms_genes <- annotation_list_concat[as.character(df_signif_enrich[,1])]
        signif_terms_genes <- lapply(signif_terms_genes, function(x) unique(x[x %in% genes]))

        final_list <- list(Significant_terms = df_signif_enrich,
                           Associated_genes = signif_terms_genes)
      } else {
        final_list <- NULL
      }
    }
    return(final_list)
}

#' Perform enrichment analysis for coexpression network modules
#'
#' Perform functional enrichment analysis for all coexpression network modules.
#'
#' @param net List object returned by \code{exp2net}.
#' @param exp Data frame of expressed genes and their expression values across samples.Gene IDs must correspond to row names and column names represent sample names.
#' @param annotation Annotation data frame with genes in the first column and functional annotation in the other columns, which can be exported from Biomart or similar databases.
#' @param column Column or columns of  \code{annotation} to be used for enrichment. Both character or numeric values with column indices can be used. If users want to supply more than one column, input a character or numeric vector. Default: all columns from \code{annotation}.
#' @param correction Multiple testing correction method. One of "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr" or "none". Default is "BH".
#' @param p P-value threshold. P-values below this threshold will be considered significant. Default is 0.05.
#'
#' @return For each module, a list containing two elements: \describe{
#'  \item{Significant_terms}{Data frame contaning significant terms and p-values}
#'  \item{Associated_genes}{List containing genes associated with each significant term}
#' }
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[bc3net]{enrichment}}
#' @rdname module_enrichment
#' @export
#'
module_enrichment <- function(net=NULL, exp, annotation, column = NULL,
                              correction = "BH", p = 0.05) {

  # Divide modules in different data frames of a list
  genes.modules <- net[[3]]
  list.gmodules <- split(genes.modules, genes.modules$Modules)

  enrichment_allmodules <- lapply(1:length(list.gmodules), function(x) {
    print(paste0("Enrichment analysis for module ", names(list.gmodules)[x],
                 "..."))

    l <- enrichment_analysis(genes = as.character(list.gmodules[[x]][,1]),
                             exp = exp,
                             annotation = annotation,
                             correction = correction, p = p)
    return(l)
  })

  names(enrichment_allmodules) <- names(list.gmodules)
  return(enrichment_allmodules)
}

#' Get 1st-order neighbors of a given gene or group of genes
#'
#' @param genes Character vector containing genes from which direct neighbors will be extracted.
#' @param net List object returned by \code{exp2net}.
#' @param cor_threshold Correlation threshold to filter connections. As a weighted network is a fully connected graph, a cutoff must be selected. Default is 0.7.
#'
#' @return List containing 1st-order neighbors for each input gene.
#'
#' @seealso \code{exp2net} \code{SFT_fit}
#' @author Fabricio Almeida-Silva
#' @export
#'
#' @rdname get_neighbors

get_neighbors <- function(genes, net, cor_threshold = 0.7) {

    net_type <- net$params$net_type
    power <- net$params$SFTpower
    edges <- net$adjacency_matrix

    edges[lower.tri(edges, diag = TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges)), stringsAsFactors = FALSE);
    colnames(edges) <- c("Gene1", "Gene2", "Weight")

    if(net_type == "signed") {
        adj_threshold <- (0.5*(1 - cor_threshold))^power
    } else if(net_type == "signed hybrid") {
        if(cor_threshold > 0) {
            adj_threshold <- cor_threshold^power
        } else {
            stop("Negative correlation chosen as threshold. Signed hybrid networks don't have negative values.")
        }
    } else if(net_type == "unsigned") {
        adj_threshold <- abs(cor_threshold)^power
    } else {
        stop("Please, specify a network type. One of 'signed', 'signed hybrid' or 'unsigned'.")
    }

    filt_edges <- edges[edges$Gene1 %in% genes | edges$Gene2 %in% genes, ]
    filt_edges <- filt_edges[filt_edges$Weight >= adj_threshold, ]

    list <- sapply(genes, function(x) {
        y <- filt_edges[rowSums(filt_edges == x) > 0, ]
        y <- c(as.character(y$Gene1), as.character(y$Gene2))
        y <- unique(y[y != x])
        y
    })
    return(list)
}

#' Filter edge list to remove spurious correlations
#'
#' @param cor_matrix Correlation matrix, such as the one returned by \code{exp2net}. It is the last element of the resulting list from \code{exp2net}.
#' @param method Method to filter spurious correlations. One of "Zscore", "optimalSFT", "pvalue" or "min_cor". See details for more information on the methods. Default: 'optimalSFT'
#' @param r_optimal_test Numeric vector with the correlation thresholds to be tested for optimal scale-free topology fit. Only valid if \code{method} equals "optimalSFT". Default: seq(0.7, 0.9, by = 0.05)
#' @param Zcutoff Minimum Z-score threshold. Only valid if \code{method} equals "Zscore". Default: 1.96
#' @param pvalue_cutoff Maximum P-value threshold. Only valid if \code{method} equals "pvalue". Default: 0.05
#' @param rcutoff Minimum correlation threshold. Only valid if \code{method} equals "min_cor". Default: 0.7
#' @param nSamples Number of samples in the dataset from which the correlation matrix was calculated. Only required if \code{method} equals "pvalue".
#' @param check_SFT Logical indicating whether to test if the resulting network is scale-free or not. Default: FALSE
#' @return A filtered edge list.
#' @details The default method ("optimalSFT") will create several different edge lists by filtering the original correlation matrix by the thresholds specified in \code{r_optimal_test}. Then, it will calculate a scale-free topology fit index for each of the possible networks and return the network that best fits the scale-free topology.
#' The method "Zscore" will apply a Fisher Z-transformation for the correlation coefficients and remove the Z-scores below the threshold specified in \code{Zcutoff}.
#' The method "pvalue" will calculate Student asymptotic p-value for the correlations and remove correlations whose p-values are above the threshold specified in \code{pvalue_cutoff}.
#' The method "min_cor" will remove correlations below the minimum correlation threshold specified in \code{rcutoff}.
#' @seealso
#'  \code{\link[WGCNA]{scaleFreeFitIndex}},\code{\link[WGCNA]{corPvalueStudent}}
#'  \code{\link[igraph]{fit_power_law}}
#' @rdname filter_edges
#' @export
#' @importFrom WGCNA scaleFreeFitIndex corPvalueStudent
#' @importFrom ggpubr ggline
#' @importFrom ggplot2 theme element_text
#' @importFrom igraph graph_from_data_frame as_adjacency_matrix fit_power_law
filter_edges <- function(cor_matrix, method = "optimalSFT",
                         r_optimal_test = seq(0.7, 0.9, by=0.05),
                         Zcutoff = 1.96, pvalue_cutoff = 0.05, rcutoff = 0.7,
                         nSamples = NULL, check_SFT = FALSE) {

  # Create edge list from adjacency matrix
  edges <- cor_matrix
  edges[lower.tri(edges, diag = TRUE)] <- NA
  edges <- na.omit(data.frame(as.table(edges)), stringsAsFactors = FALSE);
  colnames(edges) <- c("Gene1", "Gene2", "Weight")


  if(method == "Zscore") {
    # Apply Fisher-Z transformation to correlation values
    edgesZ <- edges
    edgesZ$Weight <- 0.5 * log((1+edges$Weight) / (1-edges$Weight))

    edgelist <- edgesZ[edgesZ$Weight >= Zcutoff, ]
  } else if(method == "optimalSFT") {
    cutoff <- r_optimal_test

    # Create list of edge lists, each with a different correlation threshold
    list_mat <- replicate(length(cutoff), cor_matrix, simplify = FALSE)
    degree_list <- list()
    for (i in 1:length(cutoff)) {
      list_mat[[i]][list_mat[[i]] < cutoff[i]] <- NA
      diag(list_mat[[i]]) <- 0
      degree_list[[i]] <- apply(list_mat[[i]], 1, sum, na.rm=TRUE) # Calculate degree for each list
      list_mat[[i]][lower.tri(list_mat[[i]], diag=TRUE)] <- NA
      list_mat[[i]] <- na.omit(data.frame(as.table(list_mat[[i]]), stringsAsFactors = FALSE))
    }

    # Calculate scale-free topology
    sft.rsquared <- unlist(lapply(degree_list, function(x) WGCNA::scaleFreeFitIndex(x)$Rsquared.SFT))
    max.index <- which.max(sft.rsquared)

    # Plot scale-free topology fit for r values
    plot.data <- data.frame(x=cutoff, y=sft.rsquared, stringsAsFactors = FALSE)
    ggpubr::ggline(plot.data, x = "x", y = "y", size=2,
                   color="firebrick",
                   xlab = "Correlation (r) values",
                   ylab = expression(paste("Scale-free topology fit -", R^{2})),
                   title = "Scale-free topology fit for given r values", font.title = c(17, "bold")) +
      ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))

    optimalr <- cutoff[max.index]
    print(paste("The correlation threshold that best fits the scale-free topology is", optimalr))

    edgelist <- list_mat[[max.index]]

  } else if(method == "pvalue") {
    if(is.null(nSamples)) { stop("Please, specify the number of samples used to calculate the correlation matrix")}

    # Transform symmetrical matrix in a 3-column data frame with correlations
    edges <- cor_matrix
    edges[lower.tri(edges, diag=TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges), stringsAsFactors = FALSE))
    colnames(edges) <- c("Gene1", "Gene2", "Weight")

    # Calculate Student asymptotic p-value for given correlations
    cor.pvalue <- WGCNA::corPvalueStudent(edges$Weight, nSamples)

    # Create a data frame of correlations and p-values
    corandp <- edges; corandp$pvalue <- cor.pvalue

    # Create a final edge list containing only significant correlations
    edgelist <- corandp[corandp$pvalue < pvalue_cutoff, c(1:3)]

  } else if(method == "min_cor") {
    edges <- cor_matrix
    edges[lower.tri(edges, diag = TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges), stringsAsFactors = FALSE));
    colnames(edges) <- c("Gene1", "Gene2", "Weight")

    edgelist <- edges[edges$Weight >= rcutoff, ]

  } else{
    stop("Please, specify a valid filtering method.")
  }

  if(check_SFT == TRUE) {

    # Calculate degree of the resulting graph
    graph <- igraph::graph_from_data_frame(edgelist, directed=FALSE)
    adj <- igraph::as_adjacency_matrix(graph, sparse = FALSE)
    diag(adj) <- 0
    degree <- apply(adj, 1, sum, na.rm=TRUE)

    # Test for scale-free topology fit
    test <- igraph::fit_power_law(degree)
    if(test$KS.p < 0.05) {
      print(paste("At the 95% confidence level for the Kolmogorov-Smirnov statistic, your graph does not fit the scale-free topology. P-value:", test$KS.p))
    } else{
      print(paste("Your graph fits the scale-free topology. P-value:", test$KS.p))
    }
  }

  return(edgelist)
}

#' Get edge list from an adjacency matrix for a group of genes
#'
#' @param net List object returned by \code{exp2net}.
#' @param genes Character vector containing a subset of genes from which edges will be extracted. It can be ignored if the user wants to extract an edge list for a given module instead of individual genes.
#' @param module Character with module name from which edges will be extracted. To include 2 or more modules, input the names in a character vector.
#' @param cor_threshold Correlation threshold to filter connections. As a weighted network is a fully connected graph, a cutoff must be selected. Default is 0.7.
#'
#' @return Data frame with edge list for the input genes.
#'
#' @seealso \code{SFT_fit}
#' @seealso \code{exp2net}.
#' @author Fabricio Almeida-Silva
#' @rdname get_edge_list
#' @export

get_edge_list <- function(net, genes = NULL, module = NULL,
                          cor_threshold = NULL) {
    edges <- net[[6]]
    genes_modules <- net[[3]]

    edges[lower.tri(edges, diag = TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges), stringsAsFactors = FALSE));
    colnames(edges) <- c("Gene1", "Gene2", "Weight")

    edges_m1 <- merge(edges, genes_modules, by = 1)
    colnames(edges_m1) <- c("Gene1", "Gene2", "weight", "Module1")
    edges_m2 <- merge(edges_m1, genes_modules, by.x = 2, by.y = 1)
    colnames(edges_m2) <- c("Gene1", "Gene2", "weight", "Module1", "Module2")

    # Filter by correlation threshold
    if(is.null(cor_threshold)) {
        final_edges <- edges_m2
    } else {
        final_edges <- edges_m2[edges_m2$weight >= cor_threshold, ]
    }

    if(is.null(genes)) {
        if(length(module) == 1) {
            edge_list <- final_edges[rowSums(final_edges == module) == 2, 1:3]
        } else {
            edge_list <- final_edges[final_edges$Module1 %in% module & final_edges$Module2 %in% module, ]
        }
    } else {
        edge_list <- final_edges[final_edges$Gene1 %in% genes & final_edges$Gene2 %in% genes, ]
    }
    return(edge_list)
}


#' Detect communities in a network
#'
#' @param edgelist Data frame containing the network as an edge list. First column must be node 1 and second column must be node 2. Additional columns will be interpreted as edge attributes and will be modified by this function.
#' @param method Community detection algorithm to be used. Available methods are "infomap", "edge_betweenness", "fast_greedy", "walktrap", "spinglass", "leading_eigen", "louvain", and "label_prop". Default is "infomap".
#' @return A data frame containing node names in the first column, and communities to which nodes belong in the second column.
#'
#' @seealso
#'  \code{\link[igraph]{as_data_frame}},\code{\link[igraph]{simplify}},\code{\link[igraph]{cluster_infomap}},\code{\link[igraph]{cluster_edge_betweenness}},\code{\link[igraph]{cluster_fast_greedy}},\code{\link[igraph]{cluster_walktrap}},\code{\link[igraph]{cluster_spinglass}},\code{\link[igraph]{cluster_leading_eigen}},\code{\link[igraph]{cluster_louvain}},\code{\link[igraph]{cluster_label_prop}}
#' @rdname detect_communities
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom igraph graph.data.frame simplify cluster_infomap cluster_edge_betweenness cluster_fast_greedy cluster_walktrap cluster_spinglass cluster_leading_eigen cluster_louvain cluster_label_prop
detect_communities <- function(edgelist, method = "infomap") {
    graph <- igraph::graph.data.frame(edgelist, directed = FALSE)
    graph <- igraph::simplify(graph)

    if(method == "infomap") {
        com <- igraph::cluster_infomap(graph)
    } else if(method == "edge_betweenness") {
        com <- igraph::cluster_edge_betweenness(graph)
    } else if(method == "fast_greedy") {
        com <- igraph::cluster_fast_greedy(graph)
    } else if(method == "walktrap") {
        com <- igraph::cluster_walktrap(graph)
    } else if(method == "spinglass") {
        com <- igraph::cluster_spinglass(graph)
    } else if(method == "leading_eigen") {
        com <- igraph::cluster_leading_eigen(graph)
    } else if(method == "louvain") {
        com <- igraph::cluster_louvain(graph)
    } else if(method == "label_prop") {
        com <- igraph::cluster_label_prop(graph)
    } else {
        stop("Please, specify a valid community detection algorithm.")
    }

    df_com <- as.data.frame(list(names = com$names, mem = com$membership))
    return(df_com)
}


#' Create a ggnetwork data frame from an igraph object
#'
#' @param graph Object of class igraph.
#' @param layout Network layout. One of "dh", "drl", "gem", "lgl", "fr", "graphopt", "kk" and "mds". Default is "kk".
#' @param arrow.gap Numeric indicating the distance between nodes and arrows. Default is 0.2
#' @seealso
#'  \code{\link[ggnetwork]{ggnetwork}}
#'  \code{\link[igraph]{layout_with_dh}},\code{\link[igraph]{layout_with_drl}},\code{\link[igraph]{layout_with_gem}},\code{\link[igraph]{layout_with_lgl}},\code{\link[igraph]{layout_with_fr}},\code{\link[igraph]{layout_with_graphopt}},\code{\link[igraph]{layout_with_kk}},\code{\link[igraph]{layout_with_mds}}
#' @rdname igraph2ggnetwork
#' @export
#' @author Fabricio Almeida-Silva
#' @importFrom ggnetwork ggnetwork
#' @importFrom igraph with_dh with_drl with_gem with_lgl with_fr with_graphopt with_kk with_mds
igraph2ggnetwork <- function(graph, layout = "kk", arrow.gap = 0.2) {
    if(layout == "dh") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_dh(),  arrow.gap = arrow.gap)
    } else if(layout == "drl") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_drl(), arrow.gap = arrow.gap)
    } else if(layout == "gem") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_gem(), arrow.gap = arrow.gap)
    } else if(layout == "lgl") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_lgl(), arrow.gap = arrow.gap)
    } else if(layout == "fr") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_fr(), arrow.gap = arrow.gap)
    } else if(layout == "graphopt") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_graphopt(), arrow.gap = arrow.gap)
    } else if(layout == "kk") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_kk(), arrow.gap = arrow.gap)
    } else if(layout == "mds") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_mds(), arrow.gap = arrow.gap)
    } else {
        stop("Please, specify a valid layout.")
    }
    return(ggnet)
}


#' Plot protein-protein interaction network from edge list
#'
#' @param edgelist_int Data frame containing the edge list for the PPI network. First column is the protein 1 and second column is the protein 2. All other columns are interpreted as edge attributes.
#' @param detect_communities Logical indicating whether to detect communities or not. Default is TRUE.
#' @param clustering_method Community detection algorithm to be used. Available methods are "infomap", "edge_betweenness", "fast_greedy", "walktrap", "spinglass", "leading_eigen", "louvain", and "label_prop". Default is "infomap".
#' @param show_labels Character indicating which nodes will be labeled. One of "all", "allhubs", "tophubs", or "none".
#' @param top_n_hubs Number of top hubs to be labeled. It is only valid if \code{show_labels} equals "tophubs". Default is 5.
#' @param interactive Logical indicating whether the network should be interactive or not. Default is FALSE.
#' @seealso
#'  \code{\link[igraph]{as_data_frame}},\code{\link[igraph]{degree}},\code{\link[igraph]{simplify}},\code{\link[igraph]{gorder}}
#'  \code{\link[networkD3]{igraph_to_networkD3}},\code{\link[networkD3]{forceNetwork}}
#'  \code{\link[ggnetwork]{geom_edges}},\code{\link[ggnetwork]{geom_nodes}},\code{\link[ggnetwork]{geom_nodetext}},\code{\link[ggnetwork]{theme_blank}},\code{\link[ggnetwork]{geom_nodetext_repel}}
#'  \code{\link[ggplot2]{ggplot}},\code{\link[ggplot2]{aes}},
#' @rdname plot_ppi
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom igraph graph_from_data_frame degree simplify vcount
#' @importFrom networkD3 igraph_to_networkD3 forceNetwork
#' @importFrom ggnetwork ggnetwork geom_edges geom_nodes geom_nodetext theme_blank geom_nodelabel_repel unit
#' @importFrom ggplot2 ggplot aes guides
plot_ppi <- function(edgelist_int, detect_communities = TRUE,
                     clustering_method = "infomap", show_labels = "tophubs",
                     top_n_hubs = 5, interactive = FALSE) {
    requireNamespace("intergraph", quietly=TRUE)
    nod_at <- data.frame(Gene = unique(c(as.character(edgelist_int[,1]), as.character(edgelist_int[,2]))),
                         stringsAsFactors = FALSE)

    # Add communities
    if(detect_communities == TRUE) {
        clusters <- detect_communities(edgelist_int, method = clustering_method)
        nod_at <- merge(nod_at, clusters, by.x="Gene", by.y="names")
    }

    # Add degree
    g <- igraph::graph_from_data_frame(d = edgelist_int, directed = FALSE)
    g_degree <- as.data.frame(igraph::degree(g), stringsAsFactors=FALSE); colnames(g_degree) <- "Degree"
    nod_at <- merge(nod_at, g_degree, by.x="Gene", by.y="row.names")
    nod_at <- nod_at[order(-nod_at$Degree), ]

    # Add hub gene status
    hubs <- nod_at[order(nod_at$Degree, decreasing = TRUE), ]
    hubs <- hubs[1:(nrow(hubs) / 10), ]
    nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)

    # Should the network be interactive?
    if(interactive == TRUE) {
        graph <- igraph::simplify(igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed=FALSE))

        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$mem)
        graph_d3$nodes <- merge(graph_d3$nodes, nod_at, by.x="name", by.y="Gene", sort = FALSE)
        p <- networkD3::forceNetwork(Links = graph_d3$links, Nodes = graph_d3$nodes,
                     Source = 'source', Target = 'target',
                     NodeID = 'name', Group = 'group',
                     Nodesize = 'Degree', height=900, width=1200,
                     opacity=0.8, zoom = TRUE, fontSize = 20)

    } else { #Static network
        # Define plotting parameters
        if(show_labels == "all") {
            graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
            nvertices <- igraph::vcount(graph)
            if(nvertices > 200) {
                print(paste("WARNING: Graph has more than 400 vertices. Consider displaying labels of hubs or top hubs only.
                  Number of vertices:", nvertices))
            }
            graph <- igraph::simplify(graph)
            n <- ggnetwork::ggnetwork(graph)
            n$Cluster <- as.factor(n$mem)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, color = Cluster)) +
                ggplot2::guides(color = FALSE) +
                ggnetwork::geom_nodetext(ggplot2::aes(label = name, size = 0.4 * Degree)) +
                ggnetwork::theme_blank()

        } else if(show_labels == "allhubs") {
            graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
            graph <- igraph::simplify(graph)
            n <- ggnetwork::ggnetwork(graph)
            n$Cluster <- as.factor(n$mem)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, color = Cluster)) +
                ggplot2::guides(color = FALSE) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][1:top_n_hubs]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
            graph <- igraph::simplify(graph)
            n <- ggnetwork::ggnetwork(graph)
            n$Cluster <- as.factor(n$mem)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, color = Cluster)) +
                ggplot2::guides(color = FALSE) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "none") {
            graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
            graph <- igraph::simplify(graph)
            n <- ggnetwork::ggnetwork(graph)
            n$Cluster <- as.factor(n$mem)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, color = Cluster)) +
                ggplot2::guides(color = FALSE) +
                ggnetwork::theme_blank()
        }
    }

    return(p)
}



#' Plot gene regulatory network from edge list
#'
#' @param edgelist_grn Data frame containing the edge list for the GRN network. First column is the TF and second column is the target gene. All other columns are interpreted as edge attributes.
#' @param show_labels Character indicating which nodes will be labeled. One of "all", "allhubs", "tophubs", or "none".
#' @param top_n_hubs Number of top hubs to be labeled. It is only valid if \code{show_labels} equals "tophubs". Default is 5.
#' @param interactive Logical indicating whether the network should be interactive or not. Default is FALSE.
#' @param layout Network layout. One of "dh", "drl", "gem", "lgl", "fr", "graphopt", "kk" and "mds". Default is "kk".
#' @param arrow.gap Numeric indicating the distance between nodes and arrows. Default is 0.2.
#'
#' @return A ggplot object containing the network.
#' @seealso
#'  \code{\link[igraph]{as_data_frame}},\code{\link[igraph]{degree}},\code{\link[igraph]{gorder}}
#'  \code{\link[networkD3]{igraph_to_networkD3}},\code{\link[networkD3]{forceNetwork}}
#'  \code{\link[ggplot2]{ggplot}},\code{\link[ggplot2]{aes}},\code{\link[ggplot2]{reexports}},\code{\link[ggplot2]{scale_manual}}
#'  \code{\link[ggnetwork]{geom_edges}}, \code{\link[ggnetwork]{geom_nodes}},\code{\link[ggnetwork]{geom_nodetext}},\code{\link[ggnetwork]{theme_blank}},\code{\link[ggnetwork]{geom_nodetext_repel}}
#'  \code{\link[ggnewscale]{new_scale}}
#' @rdname plot_grn
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom igraph graph_from_data_frame degree vcount
#' @importFrom networkD3 igraph_to_networkD3 forceNetwork
#' @importFrom ggplot2 ggplot aes arrow scale_color_manual guides
#' @importFrom ggnetwork geom_edges unit geom_nodes geom_nodetext theme_blank geom_nodelabel_repel
#' @importFrom ggnewscale new_scale_color
plot_grn <- function(edgelist_grn, show_labels = "tophubs", top_n_hubs = 5,
                     interactive = FALSE, layout = "kk", arrow.gap = 0.01) {
    requireNamespace("intergraph", quietly=TRUE)

    if(ncol(edgelist_grn) == 3) {
        colnames(edgelist_grn)[3] <- "Regulation"
        palette <- c("red", "blue", "grey75")
        palette2 <- c("gold2", "forestgreen", "grey75")
        showlegend <- TRUE
    } else {
        edgelist_grn$Regulation <- "none"
        palette <- c("grey75", "grey76", "grey77")
        palette2 <- c("gold2", "forestgreen")
        showlegend <- FALSE
    }

    # Start data frame of node attributes
    nod_at <- data.frame(Gene = unique(c(as.character(edgelist_grn[,1]), as.character(edgelist_grn[,2]))),
                         stringsAsFactors = FALSE)

    # Add degree
    g <- igraph::graph_from_data_frame(d = edgelist_grn, directed = TRUE)
    g_degree <- as.data.frame(igraph::degree(g, mode = "out"), stringsAsFactors=FALSE); colnames(g_degree) <- "Degree"
    nod_at <- merge(nod_at, g_degree, by.x="Gene", by.y="row.names")
    nod_at <- nod_at[order(-nod_at$Degree), ]

    # Add hub gene status
    hubs <- nod_at[order(nod_at$Degree, decreasing = TRUE), ]
    hubs <- hubs[1:(nrow(hubs) / 10), ]
    nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)

    # Add classification for TF and target gene
    nod_at$Molecule <- ifelse(nod_at$Gene %in% edgelist_grn[,1], "TF", "target")

    # Should the network be interactive?
    if(interactive == TRUE) {
        graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed=TRUE)

        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$Molecule)
        graph_d3$nodes <- merge(graph_d3$nodes, nod_at, by.x="name", by.y="Gene", sort = FALSE)
        my_color <- 'd3.scaleOrdinal() .domain(["TF", "target"]) .range(["forestgreen", "orange"])'
        p <- networkD3::forceNetwork(Links = graph_d3$links, Nodes = graph_d3$nodes,
                                     Source = 'source', Target = 'target',
                                     NodeID = 'name', Group = 'group',
                                     Value = 'value',
                                     linkColour = ifelse(graph_d3$links$value == "positive", "red", "blue"),
                                     colourScale = my_color,
                                     Nodesize = 'Degree', height=900, width=1200,
                                     opacity=1, zoom = TRUE, fontSize = 20, legend=TRUE)

    } else { #Static network
        # Define plotting parameters
        if(show_labels == "all") {
            graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed = TRUE)
            nvertices <- igraph::vcount(graph)
            if(nvertices > 200) {
                print(paste("WARNING: Graph has more than 400 vertices. Consider displaying labels of hubs or top hubs only.
                  Number of vertices:", nvertices))
            }
            n <- igraph2ggnetwork(graph, layout = layout, arrow.gap = arrow.gap)

            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(ggplot2::aes(color = Regulation), alpha = 0.5,
                                      arrow = ggplot2::arrow(length = ggnetwork::unit(0.1, "lines"), type = "closed"),
                                      curvature = 0.1, show.legend = showlegend) +
                ggplot2::scale_color_manual(values = palette) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodes(ggplot2::aes(color = Molecule, size = Degree, shape = Molecule)) +
                ggplot2::scale_color_manual(values = palette2) +
                ggnetwork::geom_nodetext(ggplot2::aes(label = name, size = 0.5 * Degree), vjust = -1) +
                ggnetwork::theme_blank()

        } else if(show_labels == "allhubs") {
            graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed = TRUE)
            n <- igraph2ggnetwork(graph, layout = layout, arrow.gap = arrow.gap)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(ggplot2::aes(color = Regulation), alpha = 0.5,
                                      arrow = ggplot2::arrow(length = ggnetwork::unit(0.1, "lines"), type = "closed"),
                                      curvature = 0.1, show.legend = showlegend) +
                ggplot2::scale_color_manual(values = palette) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodes(ggplot2::aes(color = Molecule, size = Degree, shape = Molecule)) +
                ggplot2::scale_color_manual(values = palette2) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][1:top_n_hubs]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed = TRUE)
            n <- igraph2ggnetwork(graph, layout = layout, arrow.gap = arrow.gap)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(ggplot2::aes(color = Regulation), alpha = 0.5,
                                      arrow = ggplot2::arrow(length = ggnetwork::unit(0.1, "lines"), type = "closed"),
                                      curvature = 0.1, show.legend = showlegend) +
                ggplot2::scale_color_manual(values = palette) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodes(ggplot2::aes(color = Molecule, size = Degree, shape = Molecule)) +
                ggplot2::scale_color_manual(values = palette2) +
                ggnewscale::new_scale_color() +
                ggplot2::guides(color = FALSE) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "none") {
            graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed = TRUE)
            n <- igraph2ggnetwork(graph, layout = layout, arrow.gap = arrow.gap)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(ggplot2::aes(color = Regulation), alpha = 0.5,
                                      arrow = ggplot2::arrow(length = ggnetwork::unit(0.1, "lines"), type = "closed"),
                                      curvature = 0.1, show.legend = showlegend) +
                ggplot2::scale_color_manual(values = palette) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodes(ggplot2::aes(color = Molecule, size = Degree, shape = Molecule)) +
                ggplot2::scale_color_manual(values = palette2) +
                ggnetwork::theme_blank()
        }
    }

    return(p)
}


#' Plot gene coexpression network from edge list
#'
#' @param edgelist_gcn Data frame containing the edge list for the PPI or GRN network. First column is the protein 1 (or TF) and second column is the protein 2 (or target gene). All other columns are interpreted as edge attributes.
#' @param net List object returned by \code{exp2net}.
#' @param modulename Character with the name of the module to be plotted.
#' @param hubs Data frame containing hub genes in the first column, their modules in the second column, and intramodular connectivity in the third column.
#' @param show_labels Character indicating which nodes will be labeled. One of "all", "allhubs", "tophubs", or "none".
#' @param top_n_hubs Number of top hubs to be labeled. It is only valid if \code{show_labels} equals "tophubs". Default is 5.
#' @param interactive Logical indicating whether the network should be interactive or not. Default is FALSE.
#' @seealso
#'  \code{\link[igraph]{simplify}},\code{\link[igraph]{as_data_frame}},\code{\link[igraph]{gorder}}
#'  \code{\link[networkD3]{igraph_to_networkD3}},\code{\link[networkD3]{forceNetwork}}
#'  \code{\link[ggnetwork]{geom_edges}},\code{\link[ggnetwork]{geom_nodes}},\code{\link[ggnetwork]{geom_nodetext}},\code{\link[ggnetwork]{theme_blank}},\code{\link[ggnetwork]{geom_nodetext_repel}}
#'  \code{\link[ggplot2]{ggplot}},\code{\link[ggplot2]{aes}}
#' @rdname plot_gcn
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom igraph simplify graph_from_data_frame vcount
#' @importFrom networkD3 igraph_to_networkD3 forceNetwork
#' @importFrom ggnetwork ggnetwork geom_edges geom_nodes geom_nodetext theme_blank geom_nodelabel_repel unit
#' @importFrom ggplot2 ggplot aes guides
plot_gcn <- function(edgelist_gcn, net, modulename = NULL, hubs = NULL,
                     show_labels = "tophubs", top_n_hubs = 5,
                     interactive = FALSE) {
    requireNamespace("intergraph", quietly=TRUE)
    genes_modules <- net[[3]]
    kIN <- net[[4]]

    if(is.null(modulename) | is.null(hubs) | is.null(edgelist_gcn)) {
        stop("Arguments edgelist_gcn, modulename and hubs are mandatory for this network.")
    }

    #Create a data frame of nodes and node attributes
    nod_at <- data.frame(Gene = unique(c(as.character(edgelist_gcn[,1]), as.character(edgelist_gcn[,2]))),
                         stringsAsFactors = FALSE)
    nod_at$Module <- as.character(genes_modules[genes_modules[,1] %in% nod_at$Gene, 2])
    nod_at$Degree <- kIN$kWithin[rownames(kIN) %in% nod_at$Gene]
    nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)
    nod_at <- nod_at[order(nod_at$Module, -nod_at$Degree), ]

    # Should the network be interactive?
    if(interactive == TRUE) {
        graph <- igraph::simplify(igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed=FALSE))
        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$Module)
        graph_d3$nodes <- merge(graph_d3$nodes, nod_at, by.x="name", by.y="Gene", sort = FALSE)
        p <- networkD3::forceNetwork(Links = graph_d3$links, Nodes = graph_d3$nodes,
                                     Source = 'source', Target = 'target',
                                     NodeID = 'name', Group = 'group',
                                     Nodesize = 'Degree', height=900, width=1200,
                                     opacity=0.8, zoom = TRUE, fontSize = 20)
    } else {
        # Define plotting parameters
        if(show_labels == "all") {
            nod_at$Degree2 <- nod_at$Degree
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            nvertices <- igraph::vcount(graph)
            if(nvertices > 400) {
                print(paste("WARNING: Graph has more than 400 vertices. Consider displaying labels of hubs or top hubs only.
                  Number of vertices:", nvertices))
            }
            n <- ggnetwork::ggnetwork(graph)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, alpha = Degree),
                                      color = unique(as.character(n$Module))) +
                ggnetwork::geom_nodetext(ggplot2::aes(label = name, size = 0.4 * Degree), show.legend = FALSE) +
                ggplot2::guides(alpha=FALSE) +
                ggnetwork::theme_blank()

        } else if(show_labels == "allhubs") {
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            n <- ggnetwork::ggnetwork(graph)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, alpha = Degree),
                                      color = unique(as.character(n$Module))) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][1:top_n_hubs]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            n <- ggnetwork::ggnetwork(graph)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, alpha = Degree),
                                      color = unique(as.character(n$Module))) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "none") {
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            n <- ggnetwork::ggnetwork(graph)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, alpha = Degree),
                                                   color = unique(as.character(n$Module))) +
                ggnetwork::theme_blank()
        } else {
            stop("Please, specify a valid option of show_labels.")
        }
    }
    return(p)
}

#' Calculate network statistics
#'
#' @param adj_matrix Adjacency matrix that represents the network.
#' @param net_type One of "gcn" (gene coexpression network), "ppi" (protein-protein interaction), or "grn" (gene regulatory network).
#' @param calculate_additional Logical indicating whether to calculate additional network statistics (betweenness and closeness). Default is FALSE, because it might be time-consuming.
#'
#' @return A list containing the following elements: \itemize{
#'   \item Connectivity
#'   \item ScaledConnectivity
#'   \item ClusterCoef
#'   \item MAR (for gcn only)
#'   \item Density
#'   \item Centralization
#'   \item Heterogeneity (gcn only)
#'   \item nCliques
#'   \item diameter
#'   \item betweenness
#'   \item closeness
#' }
#'
#' @seealso
#'  \code{\link[igraph]{graph_from_adjacency_matrix}},\code{\link[igraph]{cliques}},\code{\link[igraph]{diameter}},\code{\link[igraph]{estimate_betweenness}},\code{\link[igraph]{V}},\code{\link[igraph]{closeness}},\code{\link[igraph]{degree}},\code{\link[igraph]{transitivity}},\code{\link[igraph]{edge_density}},\code{\link[igraph]{centr_degree}}
#'  \code{\link[WGCNA]{fundamentalNetworkConcepts}}
#' @rdname net_stats
#' @export
#' @importFrom igraph graph_from_adjacency_matrix cliques diameter betweenness V closeness degree transitivity edge_density centralization.degree
#' @importFrom WGCNA fundamentalNetworkConcepts
net_stats <- function(adj_matrix = NULL, net_type=c("gcn", "ppi", "grn"),
                      calculate_additional = FALSE) {

  # For gene coexpression networks
  if(net_type == "gcn") {
    # Create a graph object representing an undirected weighted network
    graph <- igraph::graph_from_adjacency_matrix(adj_matrix, mode="undirected",
                                                 diag=FALSE, weighted=TRUE)
    # Calculate stats
    stats <- WGCNA::fundamentalNetworkConcepts(adj_matrix)
    stats$nCliques <- length(igraph::cliques(graph, min=3)) # number of cliques
    stats$diameter <- igraph::diameter(graph, directed=FALSE) # net diameter

    if(calculate_additional == TRUE) {
      # Calculate vertex betweenness
      betweenness <- igraph::betweenness(graph, directed = FALSE)
      names(betweenness) <- igraph::V(graph)
      stats$betweenness <- as.data.frame(betweenness)

      # Calculate closeness
      closeness <- igraph::closeness(graph, mode="all")
      names(closeness) <- igraph::V(graph)
      stats$closeness <- as.data.frame(closeness)
    }
    # For protein-protein interaction networks
  } else if(net_type == "ppi") {
    # Create a graph object representing an undirected unweighted network
    graph <- igraph::graph_from_adjacency_matrix(adj_matrix, mode="undirected",
                                                 diag=FALSE, weighted=FALSE)

    # Calculate stats
    stats <- WGCNA::fundamentalNetworkConcepts(adj_matrix)
    stats$MAR <- NULL # Remove MAR, since it doesn't make sense here
    stats$nCliques <- length(igraph::cliques(graph, min=3)) # number of cliques
    stats$diameter <- igraph::diameter(graph, directed=FALSE) # net diameter

    if(calculate_additional == TRUE) {
      # Calculate vertex betweenness
      betweenness <- igraph::betweenness(graph, directed = FALSE)
      names(betweenness) <- igraph::V(graph)
      stats$betweenness <- as.data.frame(betweenness)

      # Calculate closeness
      closeness <- igraph::closeness(graph, mode="all")
      names(closeness) <- igraph::V(graph)
      stats$closeness <- as.data.frame(closeness)
    }
    # For gene regulatory networks
  } else if(net_type == "grn") {
    graph <- igraph::graph_from_adjacency_matrix(adj_matrix, mode="directed",
                                                 diag=FALSE, weighted=FALSE)
    # Calculate stats
    degree <- igraph::degree(graph, mode = "all")
    clustercoef <- igraph::transitivity(graph, mode="global")
    density <- igraph::edge_density(graph)
    centralization <- igraph::centralization.degree(graph)$centralization
    diameter <- igraph::diameter(graph, directed=TRUE)

    if(calculate_additional == TRUE) {
      # Calculate vertex betweenness
      betweenness <- igraph::betweenness(graph, directed = TRUE)
      names(betweenness) <- igraph::V(graph)
      stats$betweenness <- as.data.frame(betweenness)

      # Calculate closeness
      closeness <- igraph::closeness(graph, mode="all")
      names(closeness) <- igraph::V(graph)
      stats$closeness <- as.data.frame(closeness)

      stats <- list(
        Connectivity = degree,
        ScaledConnectiviy = degree / max(degree),
        ClusterCoef = clustercoef,
        Density = density,
        Centralization = centralization,
        Diameter = diameter,
        Betweenness = betweenness,
        Closeness = closeness)
    } else{
      stats <- list(
        Connectivity = degree,
        ScaledConnectiviy = degree / max(degree),
        ClusterCoef = clustercoef,
        Density = density,
        Centralization = centralization,
        Diameter = diameter)
      }
  } else{
    stop("Please, specify a valid net_type. One of 'ppi', 'gcn' or 'grn'.")
  }
  return(stats)
}












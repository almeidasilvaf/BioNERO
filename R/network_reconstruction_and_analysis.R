#' Pick power to fit network to a scale-free topology
#'
#' @param exp Normalized expression table, where rownames are gene IDs and colnames are sample names
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'. Default is signed.
#' @param rsquared R squared cutoff. Default is 0.8.
#' @param cor_method Correlation method. One of "pearson", "biweight" or "spearman". Default is "spearman", considering that the expression data does not follow a normal distribution.
#' @param consensus Logical indicating if scale-free topology fit should be calculated for consensus modules or not. Default is FALSE, assuming the user wants to reconstruct a GCN for each data set individually.
#'
#' @return Power to fit network to a scale-free topology and SFT fit plots in PDF in the user's working directory
#'
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{pickSoftThreshold}}
#' @rdname SFT_fit
#' @export
#' @importFrom WGCNA pickSoftThreshold
SFT_fit <- function(exp, net_type="signed", rsquared=0.8, cor_method="spearman") {
    texp <- t(exp)

    if(cor_method == "pearson") {
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20, RsquaredCut = rsquared)
    } else if(cor_method == "biweight") {
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20,
                                        RsquaredCut = rsquared, corFnc = bicor, corOptions = list(use = 'p', maxPOutliers = 0.05))
    } else if (cor_method == "spearman"){
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20,
                                        RsquaredCut = rsquared, corOptions = list(use = 'p', method = "spearman"))
    } else {
        print("Please, specify a correlation method (one of 'spearman', 'pearson' or 'biweight').")
    }
    wgcna_power <- sft$powerEstimate
    if(is.na(wgcna_power)){
        print(paste("No power reached R-squared cut-off, now choosing max R-squared based power"))
        wgcna_power <- sft$fitIndices$Power[which(sft$fitIndices$SFT.R.sq == max(sft$fitIndices$SFT.R.sq))]
    }
    pdf(file = "SFT and power beta selection.pdf", width=12, height=9)
    par(mfrow = c(1,2));
    plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit, signed R^2",type="n",
         main = paste("Scale independence"), ylim=c(0,1));
    text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         labels=1:20,cex=0.9,col="black");
    abline(h=0.80,col="red")
    plot(sft$fitIndices[,1], sft$fitIndices[,5], main = paste("Mean connectivity"), xlab="Soft Threshold (power)", ylab="Mean connectivity (k)")
    text(sft$fitIndices[,1], sft$fitIndices[,5], labels=1:20, cex=0.9,col="red")
    dev.off()

    return(wgcna_power)
}


#' Reconstruct gene coexpression network from gene expression data frame
#'
#' @param norm.exp Normalized gene expression data frame, where row names are gene IDs and column names are sample names.
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'.
#' @param module_merging_threshold Maximum dissimilarity (1-cor) between module for module merging. As it is based on dissimilarity, a threshold of 0.2 means that module eigengenes must be at least 0.8 similar to be merged. Default is 0.2.
#' @param SFTpower SFT power generated by the function \code{SFT_fit}.
#' @param cor_method Correlation method. One of "pearson", "biweight" or "spearman". Default is "spearman", considering that the expression data does not follow a normal distribution.
#'
#' @return List containing: \itemize{
#'   \item Adjacency matrix
#'   \item Data frame of module eigengenes
#'   \item Data frame of genes and their corresponding modules
#'   \item Data frame of intramodular connectivity
#'   \item Vector of module assignment
#' }
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{adjacency}},\code{\link[WGCNA]{TOMsimilarity}},\code{\link[WGCNA]{standardColors}},\code{\link[WGCNA]{labels2colors}},\code{\link[WGCNA]{moduleEigengenes}},\code{\link[WGCNA]{plotEigengeneNetworks}},\code{\link[WGCNA]{mergeCloseModules}},\code{\link[WGCNA]{plotDendroAndColors}},\code{\link[WGCNA]{intramodularConnectivity}}
#'  \code{\link[dynamicTreeCut]{cutreeDynamicTree}}
#' @rdname exp2net
#' @export
#' @importFrom WGCNA adjacency TOMsimilarity standardColors labels2colors moduleEigengenes plotEigengeneNetworks mergeCloseModules plotDendroAndColors intramodularConnectivity
#' @importFrom dynamicTreeCut cutreeDynamicTree
exp2net <- function(norm.exp, net_type="signed hybrid", module_merging_threshold = 0.2, SFTpower, cor_method = "spearman") {
    print("Calculating adjacency matrix...")
    if(cor_method == "pearson") {
        adj_matrix <- WGCNA::adjacency(t(norm.exp), power=SFTpower, type=net_type)
    } else if(cor_method == "spearman") {
        adj_matrix <- WGCNA::adjacency(t(norm.exp), power=SFTpower, type=net_type,
                                       corOptions = list(use = "p", method = "spearman"))
    } else if (cor_method == "biweight") {
        adj_matrix <- WGCNA::adjacency(t(norm.exp), power=SFTpower, type=net_type,
                                       corFnc = bicor)
    } else {
        print("Please, specify a correlation method. One of 'spearman', 'pearson' or 'biweight'.")
    }
    print("Removing diagonals...")
    diag(adj_matrix)=0

    #Convert to matrix
    gene_ids <- rownames(adj_matrix)
    adj_matrix <- matrix(adj_matrix, nrow=nrow(adj_matrix))
    rownames(adj_matrix) <- gene_ids
    colnames(adj_matrix) <- gene_ids

    #Calculate TOM from adjacency matrix
    print("Calculating topological overlap matrix (TOM)...")
    if(net_type == "signed hybrid") {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "signed")
    } else if(net_type == "signed") {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "signed Nowick")
    } else {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "unsigned")
    }


    #Hierarchically cluster genes
    dissTOM = 1-TOM #hclust takes a distance structure
    geneTree = hclust(as.dist(dissTOM), method="average")

    #Detecting coexpression modules
    print("Detecting coexpression modules...")
    old.module_labels <- dynamicTreeCut::cutreeDynamicTree(dendro=geneTree, minModuleSize=30,
                                                           deepSplit=TRUE)

    nmod <- length(unique(old.module_labels))
    palette <- rev(WGCNA::standardColors(nmod))
    old.module_colors <- WGCNA::labels2colors(old.module_labels, colorSeq = palette)

    #Calculate eigengenes and merge the ones who are highly correlated
    print("Calculating module eigengenes (MEs)...")
    old.MElist <- WGCNA::moduleEigengenes(t(norm.exp), colors = old.module_colors, softPower = SFTpower)
    old.MEs <- old.MElist$eigengenes
    eigennetwork_beforemerging <- WGCNA::plotEigengeneNetworks(old.MEs, "",cex.lab=0.8, xLabelsAngle=90,
                                                               marDendro=c(0,4,1,3), marHeatmap=c(3,6,1,2))

    #Calculate dissimilarity of module eigengenes
    MEDiss1 <- 1-cor(old.MEs)

    #Hierarchically cluster module eigengenes to see how they're related
    old.METree <- hclust(as.dist(MEDiss1), method="average")

    #Then, choose a height cut.
    MEDissThreshold = module_merging_threshold

    #Merge the modules.
    print("Merging similar modules...")
    if(cor_method == "pearson") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3)
    } else if(cor_method == "spearman") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, corOptions = list(use = "p", method = "spearman"))
    } else if(cor_method == "biweight") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, corFnc = bicor)
    } else {
        print("Please, specify a correlation method. One of 'spearman', 'pearson' or 'biweight'.")
    }
    new.module_colors <- merge1$colors
    new.MEs <- merge1$newMEs #calculate the eigengenes of new modules

    #Plot dendrogram of merged modules eigengenes
    new.METree <- hclust(as.dist(1-cor(new.MEs)), method="average")

    pdf(file = "Eigengene_network.pdf", width=9, height=9)
    eigennetwork_aftermerging <- WGCNA::plotEigengeneNetworks(new.MEs, "", marDendro=c(0,4,1,2), marHeatmap=c(3,4,1,2))
    dev.off()

    #See dendrogram with colors to analyze how old modules and merged modules differ
    pdf(file="Dendrogram_and_module_colors_before_and_after_merging.pdf", width = 9, height=9)
    dendroandcolors_comparison <- WGCNA::plotDendroAndColors(geneTree, cbind(old.module_colors, new.module_colors), c("Unmerged", "Merged"),
                                                             dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
    dev.off()

    #Get data frame with genes and modules they belong to
    genes_and_modules <- as.data.frame(cbind(gene_ids, new.module_colors), stringsAsFactors = FALSE)

    print("Calculating intramodular connectivity...")
    intramodular_k_allmodules <- WGCNA::intramodularConnectivity(adj_matrix, new.module_colors)

    result.list <- list(adjacency_matrix = adj_matrix,
                        MEs = new.MEs,
                        genes_and_modules = genes_and_modules,
                        kIN = intramodular_k_allmodules,
                        moduleColors = new.module_colors)

    return(result.list)
}


#' Correlate module eigengenes to sample categories (e.g. tissues)
#'
#' @param exp Gene expression data frame used to reconstruct the network, with gene IDs as row names and sample names as column names.
#' @param metadata A 2-column data frame containing sample names in the first column and sample descriptions in the second column.
#' @param MEs Module eigengenes. It is the 2nd element of the result list generated by the function \code{exp2net}.
#' @param cor_method Method to calculate correlation. One of 'pearson', 'spearman' or 'kendall'. Default is 'spearman'.
#'
#' @return A heatmap showing the correlations between module eigengenes and sample categories with their associated P-values.
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{corPvalueStudent}},\code{\link[WGCNA]{labeledHeatmap}},\code{\link[WGCNA]{blueWhiteRed}}
#' @rdname module_sample_cor
#' @export
#' @importFrom WGCNA corPvalueStudent labeledHeatmap blueWhiteRed
module_sample_cor <- function(exp, metadata, MEs, cor_method="spearman") {
    sampleinfo <- metadata[metadata[,1] %in% colnames(exp), ]
    tablesamples <- table(sampleinfo)
    write.table(tablesamples, file="matrix.to.correlate.to.eigengenes.txt", quote=F, sep="\t", row.names=T)
    trait <- read.csv("matrix.to.correlate.to.eigengenes.txt", header=T, sep="\t", row.names=1, stringsAsFactors = FALSE)
    unlink("matrix.to.correlate.to.eigengenes.txt")

    modtraitcor <- cor(as.matrix(MEs), trait, use = "p", method=cor_method)
    nSamples <- ncol(exp)
    modtraitpvalue <- WGCNA::corPvalueStudent(modtraitcor, nSamples)

    textMatrix <- paste(signif(modtraitcor, 2), ", p=", signif(modtraitpvalue, 1), ")", sep = "")
    dim(textMatrix) <- dim(modtraitcor)
    par(mar = c(6, 8.5, 3, 3))

    # Display the correlation values within a heatmap plot
    pdf("ME-sample_correlation.pdf")
    ME.trait.cor <- WGCNA::labeledHeatmap(Matrix = modtraitcor, xLabels = colnames(trait), yLabels = names(MEs), ySymbols = names(MEs),
                                          colorLabels=FALSE,colors=WGCNA::blueWhiteRed(50),textMatrix=textMatrix, setStdMargins = FALSE, cex.text = 0.5,
                                          zlim = c(-1,1), cex.lab.y = 0.5, main = paste("Module-sample relationships"))
    dev.off()
}

#' Get hub genes in a given module or in all modules at once
#'
#' @param exp Gene expression data frame with gene IDs as row names and sample names as column names.
#' @param genes_modules A 2-column data frame containing genes on the first column and modules on the second column. It is the 3rd element of the output from \code{exp2net}.
#' @param MEs Data frame of module eigengenes. It is the 2nd element of the output from \code{exp2net}.
#' @param kIN Data frame with intramodular connectivity (kIN) for each gene. It is the 4th element of the output from \code{exp2net}.
#' @param cor_method Correlation method. One of 'pearson' or 'spearman' (recommended). Default is 'spearman'.
#'
#' @return Data frame containing gene IDs, modules and intramodular connectivity of all hubs.
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{signedKME}}
#' @rdname get_hubs
#' @export
#' @importFrom WGCNA signedKME
#' @importFrom dplyr filter
get_hubs <- function(exp, genes_modules, MEs, kIN, cor_method = "spearman") {

    # List of genes and modules. Each element of the list is a module.
    l1 <- split(genes_modules, f = genes_modules$new.module_colors)
    l1$grey <- NULL

    # Add kWithin info to each data frame in the list.
    l2 <- lapply(l1, function(x) merge(x, kIN, by.x = "gene_ids", by.y = "row.names"))

    # Calculate kME
    if (cor_method == "spearman") {
        MM <- WGCNA::signedKME(t(exp), MEs, corOptions = "use = 'p', method = 'spearman'")
    } else if (cor_method == "pearson") {
        MM <- WGCNA::signedKME(t(exp), MEs)
    } else {
        print("Invalid correlation method. Pick one of 'spearman' or 'pearson'.")
    }

    # Add kME info to each data frame in the list
    l3 <- lapply(l2, function(x) merge(x, MM, by.x = "gene_ids", by.y="row.names"))

    # Keep only top 10% degree genes
    l4 <- lapply(l3, function(x) x[order(x$kWithin, decreasing = TRUE), ][1:round(nrow(x) * 0.1), ])

    # Remove 'kME' from colnames
    l5 <- lapply(l4, function(x) {
        colnames(x) <- gsub("kME", "", colnames(x))
        return(x)
    })

    # Pick genes from the top 10% degree with kME above 0.8
    final_list <- lapply(l5, function(x) {
        y <- unique(x$new.module_colors)
        z <- dplyr::filter(x, y >= 0.8)
        z <- z[, c(1,2,4)]
        return(z)
    })

    hubs_df <- do.call(rbind, final_list)
    rownames(hubs_df) <- 1:nrow(hubs_df)
    colnames(hubs_df) <- c("Gene", "Module", "kWithin")
    return(hubs_df)
}


#' Perform enrichment analysis for a set of genes
#'
#' Perform enrichment analysis for functional annotation such as Gene Ontology (GO), pathway (KEGG, MapMan) or protein domains (PFAM, Panther).
#'
#' @param genes Character vector containing genes for overrepresentation analysis.
#' @param exp Gene expression data frames with gene IDs in row names and column names in column names.
#' @param annotation Annotation data frame with genes in the first column and functional annotation in the other columns, which can be exported from Biomart or similar databases.
#' @param column Column name on the data frame specified in 'annotation' used to test for enrichment (e.g. "GO.ID").
#' @param correction Multiple testing correction method. One of "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr" or "none". Default is "BH".
#' @param p P-value threshold. P-values below this threshold will be considered significant. Default is 0.05.
#'
#' @return List containing two elements: \describe{
#'  \item{Significant_terms}{Data frame contaning significant terms and p-values}
#'  \item{Associated_genes}{List containing genes associated with each significant term}
#' }
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[bc3net]{enrichment}}
#' @rdname enrichment_analysis
#' @export
#' @importFrom bc3net enrichment
enrichment_analysis <- function(genes, exp, annotation, column, correction = "BH", p = 0.05) {

    # Get a dataframe of expressed genes and their annotations
    background_genes <- rownames(exp)
    gene_column <- colnames(annotation)[1]
    gene_annotation <- annotation[, c(paste(gene_column), column)]
    background <- gene_annotation[gene_annotation[,1] %in% background_genes, ]

    # Named list of expressed genes and their annotations
    annotation_list <- split(background[,1], background[,2])

    # Perform the enrichment analysis
    enrich <- bc3net::enrichment(genes, background_genes, annotation_list, adj = correction)
    signif_enrich <- as.data.frame(enrich[enrich$padj < p, ], stringsAsFactors = FALSE)

    signif_terms_genes <- annotation_list[as.character(signif_enrich[,1])]
    signif_terms_genes <- lapply(signif_terms_genes, function(x) unique(x[x %in% genes]))

    final_list <- list(signif_enrich, signif_terms_genes); names(final_list) <- c("Significant_terms", "Associated_genes")
    return(final_list)
}


#' Get 1st-order neighbors of a given gene or group of genes
#'
#' @param genes Character vector containing genes from which direct neighbors will be extracted.
#' @param adjacency Adjacency matrix. It is the 1st element of the output from \code{exp2net}.
#' @param cor_threshold Correlation threshold to filter connections. As a weighted network is a fully connected graph, a cutoff must be selected. Default is 0.7.
#' @param net_type Network type. This information will be used to transform the correlation threshold to an adjacency threshold.
#' @param power Power used to fit scale-free topology. Output from the function \code{SFT_fit}.
#' @return List containing 1st-order neighbors for each input gene.
#'
#' @seealso \code{exp2net} \code{SFT_fit}
#' @author Fabricio Almeida-Silva
#' @export
#'
#' @rdname get_neighbors

get_neighbors <- function(genes, adjacency, cor_threshold = 0.7, net_type = c("signed", "signed hybrid", "unsigned"), power) {
    edges <- adjacency
    edges[lower.tri(edges, diag = TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges)), stringsAsFactors = FALSE); colnames(edges) <- c("Gene1", "Gene2", "Weight")

    if(net_type == "signed") {
        adj_threshold <- (0.5*(1 - cor_threshold))^power
    } else if(net_type == "signed hybrid") {
        if(cor_threshold > 0) {
            adj_threshold <- cor_threshold^power
        } else {
            stop("Negative correlation chosen as threshold. Signed hybrid networks don't have negative values.")
        }
    } else if(net_type == "unsigned") {
        adj_threshold <- abs(cor_threshold)^power
    } else {
        stop("Please, specify a network type. One of 'signed', 'signed hybrid' or 'unsigned'.")
    }

    filt_edges <- edges[edges$Gene1 %in% genes | edges$Gene2 %in% genes, ]
    filt_edges <- filt_edges[filt_edges$Weight >= adj_threshold, ]

    list <- sapply(genes, function(x) {
        y <- filt_edges[rowSums(filt_edges == x) > 0, ]
        y <- c(as.character(y$Gene1), as.character(y$Gene2))
        y <- unique(y[y != x])
        y
    })
    return(list)
}

#' Get edge list from an adjacency matrix for a group of genes
#'
#' @param adjacency Adjacency matrix. First element of the output list from \code{exp2net}.
#' @param genes_modules Data frame of genes and their corresponding modules. Third element of the output list from \code{exp2net}. Only used if the user wants to extract an edge list for a given module.
#' @param genes Character vector containing a subset of genes from which edges will be extracted. It can be ignored if the user wants to extract an edge list for a given module instead of individual genes.
#' @param module Character with module name from which edges will be extracted. To include 2 or more modules, input the names in a character vector.
#' @param cor_threshold Correlation threshold to filter connections. As a weighted network is a fully connected graph, a cutoff must be selected. Default is 0.7.
#' @param net_type Network type. This information will be used to transform the correlation threshold to an adjacency threshold.
#' @param power Power used to fit scale-free topology. Output from the function \code{SFT_fit}.
#' @return Data frame with edge list for the input genes.
#'
#' @seealso \code{SFT_fit}
#' @seealso \code{exp2net}.
#' @author Fabricio Almeida-Silva
#' @rdname get_edge_list
#' @export

get_edge_list <- function(adjacency, genes_modules, genes = NULL, module = NULL, cor_threshold = NULL,
                          net_type = NULL, power) {
    edges <- adjacency
    edges[lower.tri(edges, diag = TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges)), stringsAsFactors = FALSE);
    colnames(edges) <- c("Gene1", "Gene2", "Weight")

    edges_m1 <- merge(edges, genes_modules, by = 1)
    colnames(edges_m1) <- c("Gene1", "Gene2", "weight", "Module1")
    edges_m2 <- merge(edges_m1, genes_modules, by.x = 2, by.y = 1)
    colnames(edges_m2) <- c("Gene1", "Gene2", "weight", "Module1", "Module2")

    if(is.null(net_type)) {
        print("Building edge list for weighted network...")
    } else {
        if(net_type == "signed") {
            adj_threshold <- (0.5*(1 - cor_threshold))^power
        } else if(net_type == "signed hybrid") {
            if(cor_threshold > 0) {
                adj_threshold <- cor_threshold^power
            } else {
                stop("Negative correlation chosen as threshold. Signed hybrid networks don't have negative values.")
            }
        } else {
            adj_threshold <- abs(cor_threshold)^power
        }
    }

    if(is.null(cor_threshold)) {
        final_edges <- edges_m2
    } else {
        final_edges <- edges_m2[edges_m2$weight >= adj_threshold, ]
    }

    if(is.null(genes)) {
        if(length(module) == 1) {
            edge_list <- final_edges[rowSums(final_edges == module) == 2, 1:3]
        } else {
            edge_list <- final_edges[final_edges$Module1 %in% module & final_edges$Module2 %in% module, ]
        }
    } else {
        edge_list <- final_edges[final_edges$Gene1 %in% genes & final_edges$Gene2 %in% genes, ]
    }
    return(edge_list)
}


#' Detect communities in a network
#'
#' @param edgelist Data frame containing the network as an edge list. First column must be node 1 and second column must be node 2. Additional columns will be interpreted as edge attributes and will be modified by this function.
#' @param method Community detection algorithm to be used. Available methods are "infomap", "edge_betweenness", "fast_greedy", "walktrap", "spinglass", "leading_eigen", "louvain", and "label_prop". Default is "infomap".
#' @return A data frame containing node names in the first column, and communities to which nodes belong in the second column.
#'
#' @seealso
#'  \code{\link[igraph]{as_data_frame}},\code{\link[igraph]{simplify}},\code{\link[igraph]{cluster_infomap}},\code{\link[igraph]{cluster_edge_betweenness}},\code{\link[igraph]{cluster_fast_greedy}},\code{\link[igraph]{cluster_walktrap}},\code{\link[igraph]{cluster_spinglass}},\code{\link[igraph]{cluster_leading_eigen}},\code{\link[igraph]{cluster_louvain}},\code{\link[igraph]{cluster_label_prop}}
#' @rdname detect_communities
#' @export
#' @importFrom igraph graph.data.frame simplify cluster_infomap cluster_edge_betweenness cluster_fast_greedy cluster_walktrap cluster_spinglass cluster_leading_eigen cluster_louvain cluster_label_prop
detect_communities <- function(edgelist, method = "infomap") {
    graph <- igraph::graph.data.frame(edgelist, directed = FALSE)
    graph <- igraph::simplify(graph)

    if(method == "infomap") {
        com <- igraph::cluster_infomap(graph)
    } else if(method == "edge_betweenness") {
        com <- igraph::cluster_edge_betweenness(graph)
    } else if(method == "fast_greedy") {
        com <- igraph::cluster_fast_greedy(graph)
    } else if(method == "walktrap") {
        com <- igraph::cluster_walktrap(graph)
    } else if(method == "spinglass") {
        com <- igraph::cluster_spinglass(graph)
    } else if(method == "leading_eigen") {
        com <- igraph::cluster_leading_eigen(graph)
    } else if(method == "louvain") {
        com <- igraph::cluster_louvain(graph)
    } else if(method == "label_prop") {
        com <- igraph::cluster_label_prop(graph)
    } else {
        stop("Please, specify a valid community detection algorithm.")
    }

    df_com <- as.data.frame(list(names = com$names, mem = com$membership))
    return(df_com)
}


#' Plot network from edge list
#'
#' @param bionetwork Type of biological network. One of 'GCN' (gene coexpression network), 'PPI' (protein-protein interaction), 'GRN' (gene-regulatory network), or 'Mixed' (GCN + PPI). Default is 'GCN'.
#' @param edgelist_gcn Data frame containing the edge list for the gene coexpression network. First column is gene 1 and second column is gene 2, which is coexpressed with gene 1. All other columns are interpreted as edge attributes (e.g. weight). The edge list can be obtained from an adjacency matrix with the function \code{get_edge_list}. If bionetwork is 'PPI' or 'GRN', this parameter can be ignored.
#' @param edgelist_int Data frame containing the edge list for the PPI or GRN network. First column is the protein 1 (or TF) and second column is the protein 2 (or target gene). All other columns are interpreted as edge attributes. If bionetwork is 'GCN', this parameter can be ignored.
#' @param genes_modules Data frame containing genes in column 1 and their corresponding modules in column 2. It is the third element of the output list from \code{exp2net}.
#' @param modulename Character with name of the module to be plotted. To include 2 or more modules, input the names in a character vector.
#' @param kIN Data frame contaning intramodular connectivity for each gene in the network. It is the fourth element of the output list from \code{exp2net}.
#' @param hubs Data frame containing hub genes in the first column, their modules in the second column, and intramodular connectivity in the third column.
#' @param top_n_hubs Number of top hubs to be labeled. Default is 5.
#' @param hubs_only Logical indicating if only hub genes should be plotted. Default is FALSE.
#' @param facet Logical. If more than 1 module is chosen, should different modules be plotted in different facets? Default is TRUE.
#' @param clustering_method Community detection algorithm to be used. Available methods are "infomap", "edge_betweenness", "fast_greedy", "walktrap", "spinglass", "leading_eigen", "louvain", and "label_prop". Default is "infomap".
#' @return A ggplot object with the network.
#'
#' @seealso \code{get_edge_list}
#' @seealso \code{exp2net}.
#' @seealso \code{get_hubs}
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[igraph]{as_data_frame}},\code{\link[igraph]{degree}}
#'  \code{\link[ggnetwork]{ggnetwork}}
#' @rdname plot_network
#' @export
#' @importFrom igraph graph_from_data_frame degree
#' @importFrom ggnetwork ggnetwork
#' @import ggplot2
plot_network <- function(bionetwork = "GCN", edgelist_gcn = NULL, edgelist_int = NULL, genes_modules = NULL,
                         modulename = NULL, kIN = NULL, hubs = NULL, top_n_hubs = 5, hubs_only = FALSE,
                         layout = layout_with_drl(), facet_mod = TRUE, clustering_method = "infomap") {
    suppressPackageStartupMessages(library(intergraph))
    if(bionetwork == "GCN") {
        if(is.null(genes_modules) | is.null(modulename) | is.null(hubs) | is.null(kIN) | is.null(edgelist_gcn)) {
            stop("Arguments edgelist_gcn, genes_modules, modulename, hubs, and kIN are mandatory for this bionetwork.")
        }

        nod_at <- data.frame(Gene = unique(c(as.character(edgelist_gcn[,1]), as.character(edgelist_gcn[,2]))),
                             stringsAsFactors = FALSE)
        nod_at$Module <- as.character(genes_modules[genes_modules[,1] %in% nod_at$Gene, 2])
        nod_at$Degree <- kIN$kWithin[rownames(kIN) %in% nod_at$Gene]
        nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)
        nod_at <- nod_at[order(nod_at$Module, -nod_at$Degree), ]

        if(length(modulename) == 1) {
            # only 1 module
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][1:top_n_hubs]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            n <- ggnetwork::ggnetwork(graph, layout)
            if(hubs_only == FALSE) {
                # plot all genes in a module
                p <- ggplot(n, aes(x = x, y = y, xend = xend, yend = yend)) +
                    geom_edges(color = "#DDDDDD", alpha = 0.5, show.legend = FALSE) +
                    geom_nodes(aes(alpha = Degree, size = Degree), color = unique(as.character(n$Module))) +
                    geom_nodelabel_repel(aes(label = name, color = isHub),
                                         box.padding = unit(1, "lines"),
                                         data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                    theme_blank()
            } else {
                # plot only hubs in a module
                p <- ggplot(n[n$isHub == TRUE, ], aes(x = x, y = y, xend = xend, yend = yend)) +
                    geom_edges(color = "#DDDDDD", alpha = 0.5, show.legend = FALSE) +
                    geom_nodes(aes(alpha = Degree, size = Degree), color = unique(as.character(n$Module)), show.legend = FALSE) +
                    geom_nodelabel_repel(aes(label = name, color = isHub),
                                         box.padding = unit(1, "lines"),
                                         data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                    theme_blank()
            }
        } else {
            # more than 1 module
            nod_list <- split(nod_at, f = nod_at$Module)
            nod <- lapply(nod_list, function(x) {
                tophubs <- x[x$isHub == TRUE, 1][1:top_n_hubs]
                x$isTopHub <- ifelse(x$Gene %in% tophubs, TRUE, FALSE)
                return(x)
            })
            nod_at <- do.call(rbind, nod)
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            n <- ggnetwork::ggnetwork(graph, layout)
            n$Module <- as.character(n$Module)

            if(facet_mod == FALSE) {
                if(hubs_only == FALSE) {
                    # plot all genes in the 2+ modules
                    p <- ggplot(n, aes(x = x, y = y, xend = xend, yend = yend)) +
                        geom_edges(aes(color = Module), alpha = 0.3, show.legend = FALSE) +
                        geom_nodes(aes(alpha = Degree, size = Degree, color = Module)) +
                        scale_color_manual(values = c(modulename)) +
                        geom_nodelabel_repel(aes(label = name, color = Module),
                                             box.padding = unit(1, "lines"),
                                             data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                        theme_blank()
                } else {
                    # plot only hubs in 2+ module
                    p <- ggplot(n[n$isHub == TRUE, ], aes(x = x, y = y, xend = xend, yend = yend)) +
                        geom_edges(aes(color = Module), alpha = 0.5, show.legend = FALSE) +
                        geom_nodes(aes(alpha = Degree, size = Degree, color = Module), show.legend = FALSE) +
                        scale_color_manual(values = c(modulename)) +
                        geom_nodelabel_repel(aes(label = name, color = Module),
                                             box.padding = unit(1, "lines"),
                                             data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                        theme_blank()
                }
            } else {
                # plot all genes in a module with facets for different modules
                filtered_edges <- edgelist_gcn[edgelist_gcn$Module1 == edgelist_gcn$Module2, ]
                filtered_edges$Position <- filtered_edges$Module1
                graph <- igraph::graph_from_data_frame(d = filtered_edges, vertices = nod_at, directed = FALSE)
                n <- ggnetwork::ggnetwork(graph, layout, by = "Position")
                n$Module <- as.character(n$Module)

                if(hubs_only == FALSE) {
                    p <- ggplot(n, aes(x = x, y = y, xend = xend, yend = yend)) +
                        geom_edges(color = "#DDDDDD", alpha = 0.3, show.legend = FALSE) +
                        geom_nodes(aes(alpha = Degree, size = Degree, color = Module)) +
                        scale_color_manual(values = c(modulename)) +
                        geom_nodelabel_repel(aes(label = name, color = Module),
                                             box.padding = unit(1, "lines"),
                                             data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                        theme_blank() +
                        facet_wrap(~Module) +
                        theme_facet()

                } else {
                    # plot all hubs in a module
                    p <- ggplot(n[n$isHub == TRUE, ], aes(x = x, y = y, xend = xend, yend = yend)) +
                        geom_edges(aes(color = Module), alpha = 0.5, show.legend = FALSE) +
                        geom_nodes(aes(alpha = Degree, size = Degree, color = Module), show.legend = FALSE) +
                        scale_color_manual(values = c(modulename)) +
                        geom_nodelabel_repel(aes(label = name, color = Module),
                                             box.padding = unit(1, "lines"),
                                             data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                        theme_blank() +
                        facet_wrap(~Module) +
                        theme_facet()
                }
            }
        }
    } else if(bionetwork == "PPI") {
        # Start data frame
        nod_at <- data.frame(Gene = unique(c(as.character(edgelist_int[,1]), as.character(edgelist_int[,2]))),
                             stringsAsFactors = FALSE)

        # Add communities
        clusters <- detect_communities(edgelist_int, method = clustering_method)
        graph <- igraph::graph_from_data_frame(d = edgelist_int, directed = FALSE)
        nod_at <- merge(nod_at, clusters, by.x="Gene", by.y="names")

        # Add degree
        nod_at$Degree <- igraph::degree(graph)

        # Add hub gene status
        hubs <- nod_at[order(nod_at$Degree, decreasing = TRUE), ]
        hubs <- hubs[1:(nrow(hubs) / 10), ]
        nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)

        nod_at <- nod_at[order(-nod_at$Degree), ]
        tophubs <- nod_at[nod_at$isHub == TRUE, 1][1:top_n_hubs]
        nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
        graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
        n <- ggnetwork::ggnetwork(graph)
        n$Cluster <- as.factor(n$mem)
        p <- ggplot(n, aes(x = x, y = y, xend = xend, yend = yend)) +
            geom_edges(color = "#DDDDDD", alpha = 0.5, show.legend = FALSE) +
            geom_nodes(aes(size = Degree, color = Cluster)) +
            guides(color = FALSE) +
            geom_nodelabel_repel(aes(label = name, color = isHub),
                                 box.padding = unit(1, "lines"),
                                 data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
            theme_blank()
    } else {
        stop("Please, choose the type of biological network you want to plot.")
    }
    return(p)
}

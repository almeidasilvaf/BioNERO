---
title: "BioNERO: Easy biological network reconstruction and analysis"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BioNERO: Easy biological network reconstruction and analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE,
  fig.align = 'center',
  fig.width = 6,
  fig.height = 5
)
```

```{r setup}
library(BioNERO)
```

## 1 Data loading and pre-processing

For this tutorial, we will use soybean gene expression data in TPM, which was downloaded from the **Soybean Expression Atlas** [(Machado *et al*, 2020)](https://doi.org/10.1111/tpj.14850). This expression resource is very big, and analyzing all the available RNA-seq samples (n=1298) would be very time-consuming. For simplicity, we will use only a subset of the data base. The subset we will use comprises RNA-seq data generated by [Libault *et al*, 2010](https://doi.org/10.1111/j.1365-313X.2010.04222.x) and [Severin *et al*, 2010](https://doi.org/10.1186/1471-2229-10-160).

Each of the two TPM expression table is a different tab-delimited file. The first column contains gene IDs and the other columns contain the expression values for each sample. First, we will read both files to R and combine them into a single data frame.

```{r}
exp <- dfs2one(mypath = "./TPM_data")
metadata <- read.table("metadata.txt", header=T, sep="\t", stringsAsFactors = FALSE)
dim(exp)
head(exp)
head(metadata)
```

The combined data frame contains 56044 genes and 28 samples.

### 1.1 Step-by-step data pre-processing

This section is suitable for users who want to have more control of their data analysis, since they can inspect the data set after each pre-processing step and analyze how different options to the arguments would affect the expression data.


**Step 1:** Removing missing values. By default, `remove_na()` will replace NAs with 0. Users can also replace NAs with the mean of each row.

```{r}
exp_filt <- remove_na(exp)
sum(is.na(exp)) # checking if NAs have been removed
```


**Step 2:** Removing non-expressed genes. Here, we will remove every gene whose median value is below 1. For other options, see `?remove_nonexp`. 

```{r}
exp_filt <- remove_nonexp(exp_filt, method="median", min_exp = 1)
dim(exp_filt)
```

After step 2, the number of genes reduced to `r nrow(exp)`.


**Step 3 (optional):** Filtering genes by variance. It is reasonable to remove genes whose expression values do not vary much across samples, since we often want to find genes that are more or less expressed in particular conditions. Here, we will keep only the top 4000 most variable genes for simplicity. Users can also filter by percentile (e.g. the top 10% most variable genes).

```{r}
exp_filt <- filter_by_variance(exp_filt, n=4000)
```


**Step 4:** Removing outlying samples. There are several methods to remove outliers. We have implemented the Zk (standardized connectivity) method, which is a network-based approach to remove outlying samples. This method has proven to be more suitable for network analysis, since it can remove outliers that other methods (such as hierarchical clustering) cannot identify. By default, BioNERO considers all samples with Zk < 2 as outliers, but this parameter is flexible if users want to change it.

```{r}
dim(exp)
exp_filt <- ZKfiltering(exp_filt, cor_method = "pearson")
dim(exp)
```

**Step 5:** Adjusting for confounding artifacts. This is an important step to avoid spurious correlations resulting from confounders. The method was described by [Parsana *et al*, 2019](https://doi.org/10.1186/s13059-019-1700-9), who developed a principal component (PC)-based correction for confounders. After correction, the expression data is quantile normalized so that every gene follows an approximate normal distribution.

```{r}
exp_filt <- PC_correction(exp_filt)
```

Let's check if genes really follow an approximate normal distribution.

```{r fig.align='center', fig.height=4, fig.width=6}
par(mfrow=c(1,2))
hist(exp_filt[1,], main="Histogram of gene 1")
hist(exp_filt[2,], main="Histogram of gene 2")
```


### 1.2 Automatic, one-step data pre-processing

Alternatively, users can pre-process their data with a single function. The function `exp_preprocess` is a wrapper for the functions `remove_na`, `remove_nonexp`, `filter_by_variance`, `ZKfiltering` and `PC_correction`. The arguments passed to `exp_preprocess` will be used by each of these functions to generate a filtered expression data in a single step.

```{r}
exp_filt2 <- exp_preprocess(exp, variance_filter = TRUE, n=4000)
dim(exp_filt) == dim(exp_filt2)
finalexp <- exp_filt2 # save the filtered expression data a single object
```

```{r include=FALSE}
rm(exp_filt2)
rm(exp_filt)
rm(exp)
```

## 2 Exploratory data analysis

BioNERO includes some functions for easy data exploration. These functions were created to avoid having to type code chunks that, although small, will be used many times. Our whole idea here is to make the user experience with biological network analysis as easy and simple as possible.


**Plotting heatmaps:** the function `plot_heatmap` plots heatmaps of correlations between samples or gene expression in a single line. Users can use their preferred RColorBrewer's palette, hide/show gene names, and activate/deactivate clustering for rows and/or columns.

```{r fig.align='center', fig.height=5, fig.width=6}
# Simple heatmap of sample correlations
plot_heatmap(finalexp, type = "samplecor")

# Add sample descriptions
plot_heatmap(finalexp, type = "samplecor", col_metadata = metadata)

# Simple heatmap of gene expression
plot_heatmap(finalexp, type="expr")

# Add sample descriptions
plot_heatmap(finalexp, type="expr", col_metadata = metadata)

# Remove sample clustering
plot_heatmap(finalexp, type="expr", col_metadata = metadata, cluster_cols=FALSE)

# Remove gene clustering
plot_heatmap(finalexp, type="expr", col_metadata = metadata, cluster_rows=FALSE)
```


**Principal component analysis (PCA):** the function `plot_PCA` performs a PCA and plots PC1 vs PC2 (by default), as well the percentage of variance explained by each PC. The users can also choose to plot PC1 vs PC3 or PC2 vs PC3. Besides, if `interactive = TRUE`, the function will display an interactive PCA plot.

```{r cache=FALSE}
# Simple PCA plot
library(BioNERO)
plot_PCA(finalexp, metadata, size=4)

# Interactive PCA
plot_PCA(finalexp, metadata, size=4, interactive=TRUE)
```

Other functions exist for exploratory purposes, such as `plot_expression_profile()` and `plot_ngenes_per_module()`, but they were made to be used after gene coexpression network reconstruction or for a set of genes of interest.


## 3 Gene coexpression network reconstruction

Now that we have our filtered and normalized expression data, we can reconstruct a gene coexpression network (GCN). First of all, we need to identify the most suitable $\beta$ power that makes the network satisfy the scale-free topology. We do that with the function `SFT_fit`. Correlation values are raised to a power $\beta$ in order to amplify the distances between correlations and, hence, to make the module detection algorithm more powerful. The higher the value of $\beta$, the closer to the scale-free topology the network is. However, a very high $\beta$ power reduces mean connectivity, which is not desired. To solve this trade-off, we usually pick the lowest $\beta$ power above a certain threshold (by default in `SFT_fit`, 0.8). This avoids reducing dramatically the mean connectivity and makes the network topology close to the scale-free topology.

```{r}
power <- SFT_fit(finalexp, cor_method="pearson")
power
```

As we can see, the optimal power is `r power`. If the users want to visually inspect the simulation of different $\beta$ values, the function `SFT_fit` automatically saves a PDF figure containing this information.

Now, we can use the power calculated by `SFT_fit` to reconstruct the GCN. The function `exp2net` reconstruct a GCN and outputs a list of 5 elements, each of which can be used by other functions in the analysis.

```{r}
net <- exp2net(finalexp, net_type="signed", SFTpower=power, cor_method="pearson")
names(net)
str(net)
```

## 4 Gene coexpression network analysis

Now that we have our coexpression network, we can start exploring some of its properties. 

### 4.1 Module-trait associations

First, let's calculate module-trait correlations. In this case, tissues will be considered traits. This analysis is useful to identify modules that are positively or negatively correlated with particular traits, which means that their gene expression levels go up or down in these conditions. By treating tissues as traits, we want to identify groups of genes whose expression levels are inhibited or enhanced in particular tissues. Alternatively, one can also use continuous variables as traits, such as metabolite content, protein concentration, height, etc.

```{r}
module_trait_cor(exp=finalexp, metadata=metadata, MEs=net$MEs, 
                 cor_method="pearson")
```

The function `module_trait_cor()` also allows for plot customization. For instance:

```{r fig.width=8, fig.height=3}
# Transpose the matrix
module_trait_cor(exp=finalexp, metadata=metadata, MEs=net$MEs, 
                 cor_method="pearson", transpose = TRUE)
```

```{r}
# Change the palette (based on RColorBrewer's palette)
module_trait_cor(exp=finalexp, metadata=metadata, MEs=net$MEs,
                 cor_method="pearson", palette="PRGn")
```


### 4.2 Enrichment analysis

After identifying modules that are inhibited or enhanced in particular tissues, users would likely want to find to which biological processes (e.g. GO biological process) or pathways (e.g. KEGG, MapMan) these genes are related. This can be done with enrichment analyses, which can uncover terms (such as GO or KEGG pathways) that are found more than expected by chance in a group of genes.
To illustrate the function `enrichment_analysis()`, we will look for enriched GO biological processes in the *black* module, which has a high positive correlation with seeds. The annotation data was downloaded from **[Phytozome's Biomart](https://phytozome.jgi.doe.gov/biomart/martview/b1db572bfe777ed7e17b91c2e955deda)**. 

```{r}
# Load annotation data
annotation <- read.csv(unz("biomart_allgenes.txt.zip", "biomart_allgenes.txt"), 
                       header=TRUE, sep="\t")
enrichment_analysis(genes = net$genes_and_modules[net$genes_and_modules[,2] == "black", 1],
                    exp=finalexp,
                    annotation=annotation,
                    column="GO.ID")

```










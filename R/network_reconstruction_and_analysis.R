#' Pick power to fit network to a scale-free topology
#'
#' @param exp Normalized expression table, where rownames are gene IDs and colnames are sample names
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'. Default is signed.
#' @param rsquared R squared cutoff. Default is 0.8.
#' @param cor_method Correlation method. One of "pearson", "biweight" or "spearman". Default is "spearman", considering that the expression data does not follow a normal distribution.
#' @param consensus Logical indicating if scale-free topology fit should be calculated for consensus modules or not. Default is FALSE, assuming the user wants to reconstruct a GCN for each data set individually.
#'
#' @return Power to fit network to a scale-free topology and SFT fit plots in PDF in the user's working directory
#'
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{pickSoftThreshold}}
#' @rdname SFT_fit
#' @export
#' @importFrom WGCNA pickSoftThreshold
SFT_fit <- function(exp, net_type="signed", rsquared=0.8, cor_method="spearman") {
    texp <- t(exp)

    if(cor_method == "pearson") {
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20, RsquaredCut = rsquared)
    } else if(cor_method == "biweight") {
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20,
                                        RsquaredCut = rsquared, corFnc = bicor, corOptions = list(use = 'p', maxPOutliers = 0.05))
    } else if (cor_method == "spearman"){
        sft <- WGCNA::pickSoftThreshold(texp, networkType = net_type, powerVector=1:20,
                                        RsquaredCut = rsquared, corOptions = list(use = 'p', method = "spearman"))
    } else {
        print("Please, specify a correlation method (one of 'spearman', 'pearson' or 'biweight').")
    }
    wgcna_power <- sft$powerEstimate
    if(is.na(wgcna_power)){
        print(paste("No power reached R-squared cut-off, now choosing max R-squared based power"))
        wgcna_power <- sft$fitIndices$Power[which(sft$fitIndices$SFT.R.sq == max(sft$fitIndices$SFT.R.sq))]
    }
    pdf(file = "SFT and power beta selection.pdf", width=12, height=9)
    par(mfrow = c(1,2));
    plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit, signed R^2",type="n",
         main = paste("Scale independence"), ylim=c(0,1));
    text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         labels=1:20,cex=0.9,col="black");
    abline(h=0.80,col="red")
    plot(sft$fitIndices[,1], sft$fitIndices[,5], main = paste("Mean connectivity"), xlab="Soft Threshold (power)", ylab="Mean connectivity (k)")
    text(sft$fitIndices[,1], sft$fitIndices[,5], labels=1:20, cex=0.9,col="red")
    dev.off()

    return(wgcna_power)
}


#' Reconstruct gene coexpression network from gene expression data frame
#'
#' @param norm.exp Normalized gene expression data frame, where row names are gene IDs and column names are sample names.
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'.
#' @param module_merging_threshold Maximum dissimilarity (1-cor) between module for module merging. As it is based on dissimilarity, a threshold of 0.2 means that module eigengenes must be at least 0.8 similar to be merged. Default is 0.2.
#' @param SFTpower SFT power generated by the function \code{SFT_fit}.
#' @param cor_method Correlation method. One of "pearson", "biweight" or "spearman". Default is "spearman", considering that the expression data does not follow a normal distribution.
#'
#' @return List containing: \itemize{
#'   \item Adjacency matrix
#'   \item Data frame of module eigengenes
#'   \item Data frame of genes and their corresponding modules
#'   \item Data frame of intramodular connectivity
#'   \item Vector of module assignment
#' }
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{adjacency}},\code{\link[WGCNA]{TOMsimilarity}},\code{\link[WGCNA]{standardColors}},\code{\link[WGCNA]{labels2colors}},\code{\link[WGCNA]{moduleEigengenes}},\code{\link[WGCNA]{plotEigengeneNetworks}},\code{\link[WGCNA]{mergeCloseModules}},\code{\link[WGCNA]{plotDendroAndColors}},\code{\link[WGCNA]{intramodularConnectivity}}
#'  \code{\link[dynamicTreeCut]{cutreeDynamicTree}}
#' @rdname exp2net
#' @export
#' @importFrom WGCNA adjacency TOMsimilarity standardColors labels2colors moduleEigengenes plotEigengeneNetworks mergeCloseModules plotDendroAndColors intramodularConnectivity
#' @importFrom dynamicTreeCut cutreeDynamicTree
exp2net <- function(norm.exp, net_type="signed hybrid", module_merging_threshold = 0.2, SFTpower, cor_method = "spearman") {
    print("Calculating adjacency matrix...")
    if(cor_method == "pearson") {
        adj_matrix <- WGCNA::adjacency(t(norm.exp), power=SFTpower, type=net_type)
    } else if(cor_method == "spearman") {
        adj_matrix <- WGCNA::adjacency(t(norm.exp), power=SFTpower, type=net_type,
                                       corOptions = list(use = "p", method = "spearman"))
    } else if (cor_method == "biweight") {
        adj_matrix <- WGCNA::adjacency(t(norm.exp), power=SFTpower, type=net_type,
                                       corFnc = bicor)
    } else {
        print("Please, specify a correlation method. One of 'spearman', 'pearson' or 'biweight'.")
    }
    print("Removing diagonals...")
    diag(adj_matrix)=0

    #Convert to matrix
    gene_ids <- rownames(adj_matrix)
    adj_matrix <- matrix(adj_matrix, nrow=nrow(adj_matrix))
  rownames(adj_matrix) <- gene_ids
    colnames(adj_matrix) <- gene_ids

    #Calculate TOM from adjacency matrix
    print("Calculating topological overlap matrix (TOM)...")
    if(net_type == "signed hybrid") {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "signed")
    } else if(net_type == "signed") {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "signed Nowick")
    } else {
        TOM <- WGCNA::TOMsimilarity(adj_matrix, TOMType = "unsigned")
    }


    #Hierarchically cluster genes
    dissTOM = 1-TOM #hclust takes a distance structure
    geneTree = hclust(as.dist(dissTOM), method="average")

    #Detecting coexpression modules
    print("Detecting coexpression modules...")
    old.module_labels <- dynamicTreeCut::cutreeDynamicTree(dendro=geneTree, minModuleSize=30,
                                                           deepSplit=TRUE)

    nmod <- length(unique(old.module_labels))
    palette <- rev(WGCNA::standardColors(nmod))
    old.module_colors <- WGCNA::labels2colors(old.module_labels, colorSeq = palette)

    #Calculate eigengenes and merge the ones who are highly correlated
    print("Calculating module eigengenes (MEs)...")
    old.MElist <- WGCNA::moduleEigengenes(t(norm.exp), colors = old.module_colors, softPower = SFTpower)
    old.MEs <- old.MElist$eigengenes
    eigennetwork_beforemerging <- WGCNA::plotEigengeneNetworks(old.MEs, "",cex.lab=0.8, xLabelsAngle=90,
                                                               marDendro=c(0,4,1,3), marHeatmap=c(3,6,1,2))

    #Calculate dissimilarity of module eigengenes
    MEDiss1 <- 1-cor(old.MEs)

    #Hierarchically cluster module eigengenes to see how they're related
    old.METree <- hclust(as.dist(MEDiss1), method="average")

    #Then, choose a height cut.
    MEDissThreshold = module_merging_threshold

    #Merge the modules.
    print("Merging similar modules...")
    if(cor_method == "pearson") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3)
    } else if(cor_method == "spearman") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, corOptions = list(use = "p", method = "spearman"))
    } else if(cor_method == "biweight") {
        merge1 <- WGCNA::mergeCloseModules(t(norm.exp), old.module_colors, cutHeight = MEDissThreshold,
                                           verbose = 3, corFnc = bicor)
    } else {
        print("Please, specify a correlation method. One of 'spearman', 'pearson' or 'biweight'.")
    }
    new.module_colors <- merge1$colors
    new.MEs <- merge1$newMEs #calculate the eigengenes of new modules

    #Plot dendrogram of merged modules eigengenes
    new.METree <- hclust(as.dist(1-cor(new.MEs)), method="average")

    pdf(file = "Eigengene_network.pdf", width=9, height=9)
    eigennetwork_aftermerging <- WGCNA::plotEigengeneNetworks(new.MEs, "", marDendro=c(0,4,1,2), marHeatmap=c(3,4,1,2))
    dev.off()

    #See dendrogram with colors to analyze how old modules and merged modules differ
    pdf(file="Dendrogram_and_module_colors_before_and_after_merging.pdf", width = 9, height=9)
    dendroandcolors_comparison <- WGCNA::plotDendroAndColors(geneTree, cbind(old.module_colors, new.module_colors), c("Unmerged", "Merged"),
                                                             dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05)
    dev.off()

    #Get data frame with genes and modules they belong to
    genes_and_modules <- as.data.frame(cbind(gene_ids, new.module_colors), stringsAsFactors = FALSE)

    print("Calculating intramodular connectivity...")
    intramodular_k_allmodules <- WGCNA::intramodularConnectivity(adj_matrix, new.module_colors)

    result.list <- list(adjacency_matrix = adj_matrix,
                        MEs = new.MEs,
                        genes_and_modules = genes_and_modules,
                        kIN = intramodular_k_allmodules,
                        moduleColors = new.module_colors)

    return(result.list)
}

#' Perform module stability analysis
#'
#' @param norm.exp Normalized gene expression data frame, where row names are gene IDs and column names are sample names.
#' @param moduleColors Vector of module assignment returned by \code{exp2net}.
#' @param net_type Network type. One of 'signed', 'signed hybrid' or 'unsigned'. Default is "signed hybrid".
#' @param module_merging_threshold Maximum dissimilarity (1-cor) between module for module merging. As it is based on dissimilarity, a threshold of 0.2 means that module eigengenes must be at least 0.8 similar to be merged. Default is 0.2.
#' @param SFTpower SFT power generated by the function \code{SFT_fit}.
#' @param cor_method One of "bicor" (default) or "pearson". Spearman correlation coefficients are not allowed for this analysis.
#' @param nRuns Number of times to resample. Default is 30.
#' @return A .pdf file in the current working directory representing the module stability across the resamplings.
#' @seealso
#'  \code{\link[WGCNA]{sampledBlockwiseModules}},\code{\link[WGCNA]{Inline display of progress}},\code{\link[WGCNA]{matchLabels}},\code{\link[WGCNA]{plotDendroAndColors}}
#' @rdname module_stability
#' @export
#' @importFrom WGCNA sampledBlockwiseModules initProgInd matchLabels updateProgInd plotDendroAndColors
module_stability <- function(norm.exp, moduleColors, net_type = "signed hybrid", SFTpower, cor_method = "bicor",
                             module_merging_threshold = 0.2, nRuns = 30) {

    expr <- t(norm.exp)

    if(net_type == "signed hybrid") {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "signed",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    } else if(net_type == "signed") {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "signed Nowick",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    } else {
        mods0 <- WGCNA::sampledBlockwiseModules(
            nRuns = nRuns,
            replace = FALSE,
            datExpr = expr,
            maxBlockSize = 5000,
            corType = cor_method,
            networkType = net_type,
            TOMType = "unsigned",
            TOMDenom = "mean",
            mergeCutHeight = module_merging_threshold,
            reassignThreshold = 0,
            numericLabels = FALSE,
            checkMissingData = FALSE,
            quickCor = 0, verbose = 5)
    }

    nGenes <- ncol(expr)

    # Define a matrix of labels for the original and all resampling runs
    labels <- matrix(0, nGenes, nRuns + 1)
    labels[, 1] <- mods0[[1]]$mods$colors

    # Relabel modules in each of the resampling runs so that full and reampled modules with best overlaps have
    # the same labels. This is achieved by the function matchLabels.
    pind <- WGCNA::initProgInd()
    for (r in 2:(nRuns+1))
    {
        labels[, r] = WGCNA::matchLabels(mods0[[r-1]]$mods$colors, labels[, 1])
        pind <- WGCNA::updateProgInd((r-1)/nRuns, pind)
    }

    pdf(file = "module_stability.pdf", wi=20, h=15)
    WGCNA::plotDendroAndColors(mods0[[1]]$mods$dendrograms[[1]],
                        labels,
                        c("Full data set", paste("Resampling", c(1:nRuns))),
                        main = "Gene dendrogram and module labels from resampled data sets",
                        autoColorHeight = FALSE, colorHeight = 0.65,
                        dendroLabels = FALSE, hang = 0.03, guideHang = 0.05,
                        addGuide = TRUE, guideAll = FALSE,
                        cex.main = 2, cex.lab = 1.6, cex.colorLabels = 0.8, marAll = c(0, 5, 3, 0))
    dev.off()
}

#' Correlate module eigengenes to sample categories (e.g. tissues)
#'
#' @param exp Gene expression data frame used to reconstruct the network, with gene IDs as row names and sample names as column names.
#' @param metadata A 2-column data frame containing sample names in the first column and sample descriptions in the second column.
#' @param MEs Module eigengenes. It is the 2nd element of the result list generated by the function \code{exp2net}.
#' @param cor_method Method to calculate correlation. One of 'pearson', 'spearman' or 'kendall'. Default is 'spearman'.
#'
#' @return A heatmap showing the correlations between module eigengenes and sample categories with their associated P-values.
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{corPvalueStudent}},\code{\link[WGCNA]{labeledHeatmap}},\code{\link[WGCNA]{blueWhiteRed}}
#' @rdname module_sample_cor
#' @export
#' @importFrom WGCNA corPvalueStudent labeledHeatmap blueWhiteRed
module_sample_cor <- function(exp, metadata, MEs, cor_method="spearman") {
    sampleinfo <- metadata[metadata[,1] %in% colnames(exp), ]
    tablesamples <- table(sampleinfo)
    write.table(tablesamples, file="matrix.to.correlate.to.eigengenes.txt", quote=F, sep="\t", row.names=T)
    trait <- read.csv("matrix.to.correlate.to.eigengenes.txt", header=T, sep="\t", row.names=1, stringsAsFactors = FALSE)
    unlink("matrix.to.correlate.to.eigengenes.txt")

    modtraitcor <- cor(as.matrix(MEs), trait, use = "p", method=cor_method)
    nSamples <- ncol(exp)
    modtraitpvalue <- WGCNA::corPvalueStudent(modtraitcor, nSamples)

    textMatrix <- paste(signif(modtraitcor, 2), ", p=", signif(modtraitpvalue, 1), ")", sep = "")
    dim(textMatrix) <- dim(modtraitcor)
    par(mar = c(6, 8.5, 3, 3))

    # Display the correlation values within a heatmap plot
    pdf("ME-sample_correlation.pdf")
    ME.trait.cor <- WGCNA::labeledHeatmap(Matrix = modtraitcor, xLabels = colnames(trait), yLabels = names(MEs), ySymbols = names(MEs),
                                          colorLabels=FALSE,colors=WGCNA::blueWhiteRed(50),textMatrix=textMatrix, setStdMargins = FALSE, cex.text = 0.5,
                                          zlim = c(-1,1), cex.lab.y = 0.5, main = paste("Module-sample relationships"))
    dev.off()
}

#' Get hub genes in a given module or in all modules at once
#'
#' @param exp Gene expression data frame with gene IDs as row names and sample names as column names.
#' @param genes_modules A 2-column data frame containing genes on the first column and modules on the second column. It is the 3rd element of the output from \code{exp2net}.
#' @param MEs Data frame of module eigengenes. It is the 2nd element of the output from \code{exp2net}.
#' @param kIN Data frame with intramodular connectivity (kIN) for each gene. It is the 4th element of the output from \code{exp2net}.
#' @param cor_method Correlation method. One of 'pearson' or 'spearman' (recommended). Default is 'spearman'.
#'
#' @return Data frame containing gene IDs, modules and intramodular connectivity of all hubs.
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[WGCNA]{signedKME}}
#' @rdname get_hubs
#' @export
#' @importFrom WGCNA signedKME
#' @importFrom dplyr filter
get_hubs <- function(exp, genes_modules, MEs, kIN, cor_method = "spearman") {

    # List of genes and modules. Each element of the list is a module.
    l1 <- split(genes_modules, f = genes_modules$new.module_colors)
    l1$grey <- NULL

    # Add kWithin info to each data frame in the list.
    l2 <- lapply(l1, function(x) merge(x, kIN, by.x = "gene_ids", by.y = "row.names"))

    # Calculate kME
    if (cor_method == "spearman") {
        MM <- WGCNA::signedKME(t(exp), MEs, corOptions = "use = 'p', method = 'spearman'")
    } else if (cor_method == "pearson") {
        MM <- WGCNA::signedKME(t(exp), MEs)
    } else {
        print("Invalid correlation method. Pick one of 'spearman' or 'pearson'.")
    }

    # Add kME info to each data frame in the list
    l3 <- lapply(l2, function(x) merge(x, MM, by.x = "gene_ids", by.y="row.names"))

    # Keep only top 10% degree genes
    l4 <- lapply(l3, function(x) x[order(x$kWithin, decreasing = TRUE), ][1:round(nrow(x) * 0.1), ])

    # Remove 'kME' from colnames
    l5 <- lapply(l4, function(x) {
        colnames(x) <- gsub("kME", "", colnames(x))
        return(x)
    })

    # Pick genes from the top 10% degree with kME above 0.8
    final_list <- lapply(l5, function(x) {
        y <- unique(x$new.module_colors)
        z <- dplyr::filter(x, y >= 0.8)
        z <- z[, c(1,2,4)]
        return(z)
    })

    hubs_df <- do.call(rbind, final_list)
    rownames(hubs_df) <- 1:nrow(hubs_df)
    colnames(hubs_df) <- c("Gene", "Module", "kWithin")
    return(hubs_df)
}


#' Perform enrichment analysis for a set of genes
#'
#' Perform enrichment analysis for functional annotation such as Gene Ontology (GO), pathway (KEGG, MapMan) or protein domains (PFAM, Panther).
#'
#' @param genes Character vector containing genes for overrepresentation analysis.
#' @param exp Gene expression data frames with gene IDs in row names and column names in column names.
#' @param annotation Annotation data frame with genes in the first column and functional annotation in the other columns, which can be exported from Biomart or similar databases.
#' @param column Column name on the data frame specified in 'annotation' used to test for enrichment (e.g. "GO.ID").
#' @param correction Multiple testing correction method. One of "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr" or "none". Default is "BH".
#' @param p P-value threshold. P-values below this threshold will be considered significant. Default is 0.05.
#'
#' @return List containing two elements: \describe{
#'  \item{Significant_terms}{Data frame contaning significant terms and p-values}
#'  \item{Associated_genes}{List containing genes associated with each significant term}
#' }
#' @author Fabricio Almeida-Silva
#' @seealso
#'  \code{\link[bc3net]{enrichment}}
#' @rdname enrichment_analysis
#' @export
#' @importFrom bc3net enrichment
enrichment_analysis <- function(genes, exp, annotation, column, correction = "BH", p = 0.05) {

    # Get a dataframe of expressed genes and their annotations
    background_genes <- rownames(exp)
    gene_column <- colnames(annotation)[1]
    gene_annotation <- annotation[, c(paste(gene_column), column)]
    background <- gene_annotation[gene_annotation[,1] %in% background_genes, ]

    # Named list of expressed genes and their annotations
    annotation_list <- split(background[,1], background[,2])

    # Perform the enrichment analysis
    enrich <- bc3net::enrichment(genes, background_genes, annotation_list, adj = correction)
    signif_enrich <- as.data.frame(enrich[enrich$padj < p, ], stringsAsFactors = FALSE)

    signif_terms_genes <- annotation_list[as.character(signif_enrich[,1])]
    signif_terms_genes <- lapply(signif_terms_genes, function(x) unique(x[x %in% genes]))

    final_list <- list(signif_enrich, signif_terms_genes); names(final_list) <- c("Significant_terms", "Associated_genes")
    return(final_list)
}


#' Get 1st-order neighbors of a given gene or group of genes
#'
#' @param genes Character vector containing genes from which direct neighbors will be extracted.
#' @param adjacency Adjacency matrix. It is the 1st element of the output from \code{exp2net}.
#' @param cor_threshold Correlation threshold to filter connections. As a weighted network is a fully connected graph, a cutoff must be selected. Default is 0.7.
#' @param net_type Network type. This information will be used to transform the correlation threshold to an adjacency threshold.
#' @param power Power used to fit scale-free topology. Output from the function \code{SFT_fit}.
#' @return List containing 1st-order neighbors for each input gene.
#'
#' @seealso \code{exp2net} \code{SFT_fit}
#' @author Fabricio Almeida-Silva
#' @export
#'
#' @rdname get_neighbors

get_neighbors <- function(genes, adjacency, cor_threshold = 0.7, net_type = c("signed", "signed hybrid", "unsigned"), power) {
    edges <- adjacency
    edges[lower.tri(edges, diag = TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges)), stringsAsFactors = FALSE); colnames(edges) <- c("Gene1", "Gene2", "Weight")

    if(net_type == "signed") {
        adj_threshold <- (0.5*(1 - cor_threshold))^power
    } else if(net_type == "signed hybrid") {
        if(cor_threshold > 0) {
            adj_threshold <- cor_threshold^power
        } else {
            stop("Negative correlation chosen as threshold. Signed hybrid networks don't have negative values.")
        }
    } else if(net_type == "unsigned") {
        adj_threshold <- abs(cor_threshold)^power
    } else {
        stop("Please, specify a network type. One of 'signed', 'signed hybrid' or 'unsigned'.")
    }

    filt_edges <- edges[edges$Gene1 %in% genes | edges$Gene2 %in% genes, ]
    filt_edges <- filt_edges[filt_edges$Weight >= adj_threshold, ]

    list <- sapply(genes, function(x) {
        y <- filt_edges[rowSums(filt_edges == x) > 0, ]
        y <- c(as.character(y$Gene1), as.character(y$Gene2))
        y <- unique(y[y != x])
        y
    })
    return(list)
}

#' Get edge list from an adjacency matrix for a group of genes
#'
#' @param adjacency Adjacency matrix. First element of the output list from \code{exp2net}.
#' @param genes_modules Data frame of genes and their corresponding modules. Third element of the output list from \code{exp2net}. Only used if the user wants to extract an edge list for a given module.
#' @param genes Character vector containing a subset of genes from which edges will be extracted. It can be ignored if the user wants to extract an edge list for a given module instead of individual genes.
#' @param module Character with module name from which edges will be extracted. To include 2 or more modules, input the names in a character vector.
#' @param cor_threshold Correlation threshold to filter connections. As a weighted network is a fully connected graph, a cutoff must be selected. Default is 0.7.
#' @param net_type Network type. This information will be used to transform the correlation threshold to an adjacency threshold.
#' @param power Power used to fit scale-free topology. Output from the function \code{SFT_fit}.
#' @return Data frame with edge list for the input genes.
#'
#' @seealso \code{SFT_fit}
#' @seealso \code{exp2net}.
#' @author Fabricio Almeida-Silva
#' @rdname get_edge_list
#' @export

get_edge_list <- function(adjacency, genes_modules, genes = NULL, module = NULL, cor_threshold = NULL,
                          net_type = NULL, power) {
    edges <- adjacency
    edges[lower.tri(edges, diag = TRUE)] <- NA
    edges <- na.omit(data.frame(as.table(edges)), stringsAsFactors = FALSE);
    colnames(edges) <- c("Gene1", "Gene2", "Weight")

    edges_m1 <- merge(edges, genes_modules, by = 1)
    colnames(edges_m1) <- c("Gene1", "Gene2", "weight", "Module1")
    edges_m2 <- merge(edges_m1, genes_modules, by.x = 2, by.y = 1)
    colnames(edges_m2) <- c("Gene1", "Gene2", "weight", "Module1", "Module2")

    if(is.null(net_type)) {
        print("Building edge list for weighted network...")
    } else {
        if(net_type == "signed") {
            adj_threshold <- (0.5*(1 - cor_threshold))^power
        } else if(net_type == "signed hybrid") {
            if(cor_threshold > 0) {
                adj_threshold <- cor_threshold^power
            } else {
                stop("Negative correlation chosen as threshold. Signed hybrid networks don't have negative values.")
            }
        } else {
            adj_threshold <- abs(cor_threshold)^power
        }
    }

    if(is.null(cor_threshold)) {
        final_edges <- edges_m2
    } else {
        final_edges <- edges_m2[edges_m2$weight >= adj_threshold, ]
    }

    if(is.null(genes)) {
        if(length(module) == 1) {
            edge_list <- final_edges[rowSums(final_edges == module) == 2, 1:3]
        } else {
            edge_list <- final_edges[final_edges$Module1 %in% module & final_edges$Module2 %in% module, ]
        }
    } else {
        edge_list <- final_edges[final_edges$Gene1 %in% genes & final_edges$Gene2 %in% genes, ]
    }
    return(edge_list)
}


#' Detect communities in a network
#'
#' @param edgelist Data frame containing the network as an edge list. First column must be node 1 and second column must be node 2. Additional columns will be interpreted as edge attributes and will be modified by this function.
#' @param method Community detection algorithm to be used. Available methods are "infomap", "edge_betweenness", "fast_greedy", "walktrap", "spinglass", "leading_eigen", "louvain", and "label_prop". Default is "infomap".
#' @return A data frame containing node names in the first column, and communities to which nodes belong in the second column.
#'
#' @seealso
#'  \code{\link[igraph]{as_data_frame}},\code{\link[igraph]{simplify}},\code{\link[igraph]{cluster_infomap}},\code{\link[igraph]{cluster_edge_betweenness}},\code{\link[igraph]{cluster_fast_greedy}},\code{\link[igraph]{cluster_walktrap}},\code{\link[igraph]{cluster_spinglass}},\code{\link[igraph]{cluster_leading_eigen}},\code{\link[igraph]{cluster_louvain}},\code{\link[igraph]{cluster_label_prop}}
#' @rdname detect_communities
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom igraph graph.data.frame simplify cluster_infomap cluster_edge_betweenness cluster_fast_greedy cluster_walktrap cluster_spinglass cluster_leading_eigen cluster_louvain cluster_label_prop
detect_communities <- function(edgelist, method = "infomap") {
    graph <- igraph::graph.data.frame(edgelist, directed = FALSE)
    graph <- igraph::simplify(graph)

    if(method == "infomap") {
        com <- igraph::cluster_infomap(graph)
    } else if(method == "edge_betweenness") {
        com <- igraph::cluster_edge_betweenness(graph)
    } else if(method == "fast_greedy") {
        com <- igraph::cluster_fast_greedy(graph)
    } else if(method == "walktrap") {
        com <- igraph::cluster_walktrap(graph)
    } else if(method == "spinglass") {
        com <- igraph::cluster_spinglass(graph)
    } else if(method == "leading_eigen") {
        com <- igraph::cluster_leading_eigen(graph)
    } else if(method == "louvain") {
        com <- igraph::cluster_louvain(graph)
    } else if(method == "label_prop") {
        com <- igraph::cluster_label_prop(graph)
    } else {
        stop("Please, specify a valid community detection algorithm.")
    }

    df_com <- as.data.frame(list(names = com$names, mem = com$membership))
    return(df_com)
}


#' Create a ggnetwork data frame from an igraph object
#'
#' @param graph Object of class igraph.
#' @param layout Network layout. One of "dh", "drl", "gem", "lgl", "fr", "graphopt", "kk" and "mds". Default is "kk".
#' @param arrow.gap Numeric indicating the distance between nodes and arrows. Default is 0.2
#' @seealso
#'  \code{\link[ggnetwork]{ggnetwork}}
#'  \code{\link[igraph]{layout_with_dh}},\code{\link[igraph]{layout_with_drl}},\code{\link[igraph]{layout_with_gem}},\code{\link[igraph]{layout_with_lgl}},\code{\link[igraph]{layout_with_fr}},\code{\link[igraph]{layout_with_graphopt}},\code{\link[igraph]{layout_with_kk}},\code{\link[igraph]{layout_with_mds}}
#' @rdname igraph2ggnetwork
#' @export
#' @author Fabricio Almeida-Silva
#' @importFrom ggnetwork ggnetwork
#' @importFrom igraph with_dh with_drl with_gem with_lgl with_fr with_graphopt with_kk with_mds
igraph2ggnetwork <- function(graph, layout = "kk", arrow.gap = 0.2) {
    if(layout == "dh") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_dh(),  arrow.gap = arrow.gap)
    } else if(layout == "drl") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_drl(), arrow.gap = arrow.gap)
    } else if(layout == "gem") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_gem(), arrow.gap = arrow.gap)
    } else if(layout == "lgl") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_lgl(), arrow.gap = arrow.gap)
    } else if(layout == "fr") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_fr(), arrow.gap = arrow.gap)
    } else if(layout == "graphopt") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_graphopt(), arrow.gap = arrow.gap)
    } else if(layout == "kk") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_kk(), arrow.gap = arrow.gap)
    } else if(layout == "mds") {
        ggnet <- ggnetwork::ggnetwork(graph, layout = igraph::with_mds(), arrow.gap = arrow.gap)
    } else {
        stop("Please, specify a valid layout.")
    }
    return(ggnet)
}


#' Plot protein-protein interaction network from edge list
#'
#' @param edgelist_int Data frame containing the edge list for the PPI network. First column is the protein 1 and second column is the protein 2. All other columns are interpreted as edge attributes.
#' @param detect_communities Logical indicating whether to detect communities or not. Default is TRUE.
#' @param clustering_method Community detection algorithm to be used. Available methods are "infomap", "edge_betweenness", "fast_greedy", "walktrap", "spinglass", "leading_eigen", "louvain", and "label_prop". Default is "infomap".
#' @param show_labels Character indicating which nodes will be labeled. One of "all", "allhubs", "tophubs", or "none".
#' @param top_n_hubs Number of top hubs to be labeled. It is only valid if \code{show_labels} equals "tophubs". Default is 5.
#' @param interactive Logical indicating whether the network should be interactive or not. Default is FALSE.
#' @seealso
#'  \code{\link[igraph]{as_data_frame}},\code{\link[igraph]{degree}},\code{\link[igraph]{simplify}},\code{\link[igraph]{gorder}}
#'  \code{\link[networkD3]{igraph_to_networkD3}},\code{\link[networkD3]{forceNetwork}}
#'  \code{\link[ggnetwork]{c("ggnetwork", "ggnetwork", "ggnetwork")}},\code{\link[ggnetwork]{geom_edges}},\code{\link[ggnetwork]{geom_nodes}},\code{\link[ggnetwork]{geom_nodetext}},\code{\link[ggnetwork]{theme_blank}},\code{\link[ggnetwork]{geom_nodetext_repel}},\code{\link[ggnetwork]{c("unit", "unit")}}
#'  \code{\link[ggplot2]{ggplot}},\code{\link[ggplot2]{aes}},\code{\link[ggplot2]{c("guide_bins", "guide_colourbar", "guide_coloursteps", "guide_legend", "guides", "guides")}}
#' @rdname plot_ppi
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom igraph graph_from_data_frame degree simplify vcount
#' @importFrom networkD3 igraph_to_networkD3 forceNetwork
#' @importFrom ggnetwork ggnetwork geom_edges geom_nodes geom_nodetext theme_blank geom_nodelabel_repel unit
#' @importFrom ggplot2 ggplot aes guides
plot_ppi <- function(edgelist_int, detect_communities = TRUE, clustering_method = "infomap", show_labels = "tophubs",
                     top_n_hubs = 5, interactive = FALSE) {
    suppressPackageStartupMessages(library(intergraph))
    nod_at <- data.frame(Gene = unique(c(as.character(edgelist_int[,1]), as.character(edgelist_int[,2]))),
                         stringsAsFactors = FALSE)

    # Add communities
    if(detect_communities == TRUE) {
        clusters <- detect_communities(edgelist_int, method = clustering_method)
        nod_at <- merge(nod_at, clusters, by.x="Gene", by.y="names")
    }

    # Add degree
    g <- igraph::graph_from_data_frame(d = edgelist_int, directed = FALSE)
    g_degree <- as.data.frame(igraph::degree(g), stringsAsFactors=FALSE); colnames(g_degree) <- "Degree"
    nod_at <- merge(nod_at, g_degree, by.x="Gene", by.y="row.names")
    nod_at <- nod_at[order(-nod_at$Degree), ]

    # Add hub gene status
    hubs <- nod_at[order(nod_at$Degree, decreasing = TRUE), ]
    hubs <- hubs[1:(nrow(hubs) / 10), ]
    nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)

    # Should the network be interactive?
    if(interactive == TRUE) {
        graph <- igraph::simplify(igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed=FALSE))

        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$mem)
        graph_d3$nodes <- merge(graph_d3$nodes, nod_at, by.x="name", by.y="Gene", sort = FALSE)
        p <- networkD3::forceNetwork(Links = graph_d3$links, Nodes = graph_d3$nodes,
                     Source = 'source', Target = 'target',
                     NodeID = 'name', Group = 'group',
                     Nodesize = 'Degree', height=900, width=1200,
                     opacity=0.8, zoom = TRUE, fontSize = 20)

    } else { #Static network
        # Define plotting parameters
        if(show_labels == "all") {
            graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
            nvertices <- igraph::vcount(graph)
            if(nvertices > 200) {
                print(paste("WARNING: Graph has more than 400 vertices. Consider displaying labels of hubs or top hubs only.
                  Number of vertices:", nvertices))
            }
            graph <- igraph::simplify(graph)
            n <- ggnetwork::ggnetwork(graph)
            n$Cluster <- as.factor(n$mem)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, color = Cluster)) +
                ggplot2::guides(color = FALSE) +
                ggnetwork::geom_nodetext(ggplot2::aes(label = name, size = 0.4 * Degree)) +
                ggnetwork::theme_blank()

        } else if(show_labels == "allhubs") {
            graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
            graph <- igraph::simplify(graph)
            n <- ggnetwork::ggnetwork(graph)
            n$Cluster <- as.factor(n$mem)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, color = Cluster)) +
                ggplot2::guides(color = FALSE) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][1:top_n_hubs]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
            graph <- igraph::simplify(graph)
            n <- ggnetwork::ggnetwork(graph)
            n$Cluster <- as.factor(n$mem)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, color = Cluster)) +
                ggplot2::guides(color = FALSE) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "none") {
            graph <- igraph::graph_from_data_frame(d = edgelist_int, vertices = nod_at, directed = FALSE)
            graph <- igraph::simplify(graph)
            n <- ggnetwork::ggnetwork(graph)
            n$Cluster <- as.factor(n$mem)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, color = Cluster)) +
                ggplot2::guides(color = FALSE) +
                ggnetwork::theme_blank()
        }
    }

    return(p)
}



#' Plot gene regulatory network from edge list
#'
#' @param edgelist_grn Data frame containing the edge list for the GRN network. First column is the TF and second column is the target gene. All other columns are interpreted as edge attributes.
#' @param show_labels Character indicating which nodes will be labeled. One of "all", "allhubs", "tophubs", or "none".
#' @param top_n_hubs Number of top hubs to be labeled. It is only valid if \code{show_labels} equals "tophubs". Default is 5.
#' @param interactive Logical indicating whether the network should be interactive or not. Default is FALSE.
#' @param layout Network layout. One of "dh", "drl", "gem", "lgl", "fr", "graphopt", "kk" and "mds". Default is "kk".
#' @param arrow.gap Numeric indicating the distance between nodes and arrows. Default is 0.2.
#'
#' @return A ggplot object containing the network.
#' @seealso
#'  \code{\link[igraph]{as_data_frame}},\code{\link[igraph]{degree}},\code{\link[igraph]{gorder}}
#'  \code{\link[networkD3]{igraph_to_networkD3}},\code{\link[networkD3]{forceNetwork}}
#'  \code{\link[ggplot2]{ggplot}},\code{\link[ggplot2]{aes}},\code{\link[ggplot2]{reexports}},\code{\link[ggplot2]{scale_manual}},\code{\link[ggplot2]{c("guide_bins", "guide_colourbar", "guide_coloursteps", "guide_legend", "guides", "guides")}}
#'  \code{\link[ggnetwork]{geom_edges}},\code{\link[ggnetwork]{c("unit", "unit")}},\code{\link[ggnetwork]{geom_nodes}},\code{\link[ggnetwork]{geom_nodetext}},\code{\link[ggnetwork]{theme_blank}},\code{\link[ggnetwork]{geom_nodetext_repel}}
#'  \code{\link[ggnewscale]{new_scale}}
#' @rdname plot_grn
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom igraph graph_from_data_frame degree vcount
#' @importFrom networkD3 igraph_to_networkD3 forceNetwork
#' @importFrom ggplot2 ggplot aes arrow scale_color_manual guides
#' @importFrom ggnetwork geom_edges unit geom_nodes geom_nodetext theme_blank geom_nodelabel_repel
#' @importFrom ggnewscale new_scale_color
plot_grn <- function(edgelist_grn, show_labels = "tophubs", top_n_hubs = 5, interactive = FALSE,
                     layout = "kk", arrow.gap = 0.01) {
    suppressPackageStartupMessages(library(intergraph))

    if(ncol(edgelist_grn) == 3) {
        colnames(edgelist_grn)[3] <- "Regulation"
        palette <- c("red", "blue", "grey75")
        palette2 <- c("gold2", "forestgreen", "grey75")
        showlegend <- TRUE
    } else {
        edgelist_grn$Regulation <- "none"
        palette <- c("grey75", "grey76", "grey77")
        palette2 <- c("gold2", "forestgreen")
        showlegend <- FALSE
    }

    # Start data frame of node attributes
    nod_at <- data.frame(Gene = unique(c(as.character(edgelist_grn[,1]), as.character(edgelist_grn[,2]))),
                         stringsAsFactors = FALSE)

    # Add degree
    g <- igraph::graph_from_data_frame(d = edgelist_grn, directed = TRUE)
    g_degree <- as.data.frame(igraph::degree(g, mode = "out"), stringsAsFactors=FALSE); colnames(g_degree) <- "Degree"
    nod_at <- merge(nod_at, g_degree, by.x="Gene", by.y="row.names")
    nod_at <- nod_at[order(-nod_at$Degree), ]

    # Add hub gene status
    hubs <- nod_at[order(nod_at$Degree, decreasing = TRUE), ]
    hubs <- hubs[1:(nrow(hubs) / 10), ]
    nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)

    # Add classification for TF and target gene
    nod_at$Molecule <- ifelse(nod_at$Gene %in% edgelist_grn[,1], "TF", "target")

    # Should the network be interactive?
    if(interactive == TRUE) {
        graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed=TRUE)

        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$Molecule)
        graph_d3$nodes <- merge(graph_d3$nodes, nod_at, by.x="name", by.y="Gene", sort = FALSE)
        my_color <- 'd3.scaleOrdinal() .domain(["TF", "target"]) .range(["forestgreen", "orange"])'
        p <- networkD3::forceNetwork(Links = graph_d3$links, Nodes = graph_d3$nodes,
                                     Source = 'source', Target = 'target',
                                     NodeID = 'name', Group = 'group',
                                     Value = 'value',
                                     linkColour = ifelse(graph_d3$links$value == "positive", "red", "blue"),
                                     colourScale = my_color,
                                     Nodesize = 'Degree', height=900, width=1200,
                                     opacity=1, zoom = TRUE, fontSize = 20, legend=TRUE)

    } else { #Static network
        # Define plotting parameters
        if(show_labels == "all") {
            graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed = TRUE)
            nvertices <- igraph::vcount(graph)
            if(nvertices > 200) {
                print(paste("WARNING: Graph has more than 400 vertices. Consider displaying labels of hubs or top hubs only.
                  Number of vertices:", nvertices))
            }
            n <- igraph2ggnetwork(graph, layout = layout, arrow.gap = arrow.gap)

            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(ggplot2::aes(color = Regulation), alpha = 0.5,
                                      arrow = ggplot2::arrow(length = ggnetwork::unit(0.1, "lines"), type = "closed"),
                                      curvature = 0.1, show.legend = showlegend) +
                ggplot2::scale_color_manual(values = palette) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodes(ggplot2::aes(color = Molecule, size = Degree, shape = Molecule)) +
                ggplot2::scale_color_manual(values = palette2) +
                ggnetwork::geom_nodetext(ggplot2::aes(label = name, size = 0.5 * Degree), vjust = -1) +
                ggnetwork::theme_blank()

        } else if(show_labels == "allhubs") {
            graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed = TRUE)
            n <- igraph2ggnetwork(graph, layout = layout, arrow.gap = arrow.gap)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(ggplot2::aes(color = Regulation), alpha = 0.5,
                                      arrow = ggplot2::arrow(length = ggnetwork::unit(0.1, "lines"), type = "closed"),
                                      curvature = 0.1, show.legend = showlegend) +
                ggplot2::scale_color_manual(values = palette) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodes(ggplot2::aes(color = Molecule, size = Degree, shape = Molecule)) +
                ggplot2::scale_color_manual(values = palette2) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][1:top_n_hubs]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed = TRUE)
            n <- igraph2ggnetwork(graph, layout = layout, arrow.gap = arrow.gap)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(ggplot2::aes(color = Regulation), alpha = 0.5,
                                      arrow = ggplot2::arrow(length = ggnetwork::unit(0.1, "lines"), type = "closed"),
                                      curvature = 0.1, show.legend = showlegend) +
                ggplot2::scale_color_manual(values = palette) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodes(ggplot2::aes(color = Molecule, size = Degree, shape = Molecule)) +
                ggplot2::scale_color_manual(values = palette2) +
                ggnewscale::new_scale_color() +
                ggplot2::guides(color = FALSE) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "none") {
            graph <- igraph::graph_from_data_frame(d = edgelist_grn, vertices = nod_at, directed = TRUE)
            n <- igraph2ggnetwork(graph, layout = layout, arrow.gap = arrow.gap)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(ggplot2::aes(color = Regulation), alpha = 0.5,
                                      arrow = ggplot2::arrow(length = ggnetwork::unit(0.1, "lines"), type = "closed"),
                                      curvature = 0.1, show.legend = showlegend) +
                ggplot2::scale_color_manual(values = palette) +
                ggnewscale::new_scale_color() +
                ggnetwork::geom_nodes(ggplot2::aes(color = Molecule, size = Degree, shape = Molecule)) +
                ggplot2::scale_color_manual(values = palette2) +
                ggnetwork::theme_blank()
        }
    }

    return(p)
}


#' Plot gene coexpression network from edge list
#'
#' @param edgelist_gcn Data frame containing the edge list for the PPI or GRN network. First column is the protein 1 (or TF) and second column is the protein 2 (or target gene). All other columns are interpreted as edge attributes.
#' @param genes_modules Data frame containing genes in column 1 and their corresponding modules in column 2. It is the third element of the output list from \code{exp2net}.
#' @param modulename Character with the name of the module to be plotted.
#' @param kIN Data frame containing intramodular connectivity for each gene in the network. It is the fourth element of the output list from \code{exp2net}.
#' @param hubs Data frame containing hub genes in the first column, their modules in the second column, and intramodular connectivity in the third column.
#' @param show_labels Character indicating which nodes will be labeled. One of "all", "allhubs", "tophubs", or "none".
#' @param top_n_hubs Number of top hubs to be labeled. It is only valid if \code{show_labels} equals "tophubs". Default is 5.
#' @param interactive Logical indicating whether the network should be interactive or not. Default is FALSE.
#' @seealso
#'  \code{\link[igraph]{simplify}},\code{\link[igraph]{as_data_frame}},\code{\link[igraph]{gorder}}
#'  \code{\link[networkD3]{igraph_to_networkD3}},\code{\link[networkD3]{forceNetwork}}
#'  \code{\link[ggnetwork]{c("ggnetwork", "ggnetwork", "ggnetwork")}},\code{\link[ggnetwork]{geom_edges}},\code{\link[ggnetwork]{geom_nodes}},\code{\link[ggnetwork]{geom_nodetext}},\code{\link[ggnetwork]{theme_blank}},\code{\link[ggnetwork]{geom_nodetext_repel}},\code{\link[ggnetwork]{c("unit", "unit")}}
#'  \code{\link[ggplot2]{ggplot}},\code{\link[ggplot2]{aes}},\code{\link[ggplot2]{c("guide_bins", "guide_colourbar", "guide_coloursteps", "guide_legend", "guides", "guides")}}
#' @rdname plot_gcn
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom igraph simplify graph_from_data_frame vcount
#' @importFrom networkD3 igraph_to_networkD3 forceNetwork
#' @importFrom ggnetwork ggnetwork geom_edges geom_nodes geom_nodetext theme_blank geom_nodelabel_repel unit
#' @importFrom ggplot2 ggplot aes guides
plot_gcn <- function(edgelist_gcn, genes_modules = NULL, modulename = NULL, kIN = NULL, hubs = NULL,
                     show_labels = "tophubs", top_n_hubs = 5, interactive = FALSE) {
    suppressPackageStartupMessages(library(intergraph))
    if(is.null(genes_modules) | is.null(modulename) | is.null(hubs) | is.null(kIN) | is.null(edgelist_gcn)) {
        stop("Arguments edgelist_gcn, genes_modules, modulename, hubs, and kIN are mandatory for this bionetwork.")
    }

    #Create a data frame of nodes and node attributes
    nod_at <- data.frame(Gene = unique(c(as.character(edgelist_gcn[,1]), as.character(edgelist_gcn[,2]))),
                         stringsAsFactors = FALSE)
    nod_at$Module <- as.character(genes_modules[genes_modules[,1] %in% nod_at$Gene, 2])
    nod_at$Degree <- kIN$kWithin[rownames(kIN) %in% nod_at$Gene]
    nod_at$isHub <- ifelse(nod_at$Gene %in% hubs[,1], TRUE, FALSE)
    nod_at <- nod_at[order(nod_at$Module, -nod_at$Degree), ]

    # Should the network be interactive?
    if(interactive == TRUE) {
        graph <- igraph::simplify(igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed=FALSE))
        graph_d3 <- networkD3::igraph_to_networkD3(graph, group = nod_at$Module)
        graph_d3$nodes <- merge(graph_d3$nodes, nod_at, by.x="name", by.y="Gene", sort = FALSE)
        p <- networkD3::forceNetwork(Links = graph_d3$links, Nodes = graph_d3$nodes,
                                     Source = 'source', Target = 'target',
                                     NodeID = 'name', Group = 'group',
                                     Nodesize = 'Degree', height=900, width=1200,
                                     opacity=0.8, zoom = TRUE, fontSize = 20)
    } else {
        # Define plotting parameters
        if(show_labels == "all") {
            nod_at$Degree2 <- nod_at$Degree
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            nvertices <- igraph::vcount(graph)
            if(nvertices > 200) {
                print(paste("WARNING: Graph has more than 400 vertices. Consider displaying labels of hubs or top hubs only.
                  Number of vertices:", nvertices))
            }
            n <- ggnetwork::ggnetwork(graph)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, alpha = Degree),
                                      color = unique(as.character(n$Module))) +
                ggnetwork::geom_nodetext(ggplot2::aes(label = name, size = 0.4 * Degree), show.legend = FALSE) +
                ggplot2::guides(alpha=FALSE) +
                ggnetwork::theme_blank()

        } else if(show_labels == "allhubs") {
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            n <- ggnetwork::ggnetwork(graph)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, alpha = Degree),
                                      color = unique(as.character(n$Module))) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "tophubs") {
            tophubs <- nod_at[nod_at$isHub == TRUE, 1][1:top_n_hubs]
            nod_at$isTopHub <- ifelse(nod_at$Gene %in% tophubs, TRUE, FALSE)
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            n <- ggnetwork::ggnetwork(graph)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, alpha = Degree),
                                      color = unique(as.character(n$Module))) +
                ggnetwork::geom_nodelabel_repel(ggplot2::aes(label = name, color = isHub),
                                                box.padding = ggnetwork::unit(1, "lines"),
                                                data = function(x) { x[ x$isTopHub, ]}, show.legend = FALSE) +
                ggnetwork::theme_blank()
        } else if(show_labels == "none") {
            graph <- igraph::graph_from_data_frame(d = edgelist_gcn, vertices = nod_at, directed = FALSE)
            n <- ggnetwork::ggnetwork(graph)
            p <- ggplot2::ggplot(n, ggplot2::aes(x = x, y = y, xend = xend, yend = yend)) +
                ggnetwork::geom_edges(color = "grey75", alpha = 0.5, show.legend = FALSE) +
                ggnetwork::geom_nodes(ggplot2::aes(size = Degree, alpha = Degree),
                                                   color = unique(as.character(n$Module))) +
                ggnetwork::theme_blank()
        } else {
            stop("Please, specify a valid option of show_labels.")
        }
    }
    return(p)
}

